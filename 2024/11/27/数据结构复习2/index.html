<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构复习2 | Ysmmm的快乐小屋</title><meta name="author" content="Ysmmm"><meta name="copyright" content="Ysmmm"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="串(String)string类 用到了string.h的一些操作，应该学学,上网搜一下就好了  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构复习2">
<meta property="og:url" content="https://yansmaoa.github.io/2024/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A02/index.html">
<meta property="og:site_name" content="Ysmmm的快乐小屋">
<meta property="og:description" content="串(String)string类 用到了string.h的一些操作，应该学学,上网搜一下就好了  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yansmaoa.github.io/img/v2-1cb481e27656b14e14b2878d6c47e544_r.jpg">
<meta property="article:published_time" content="2024-11-26T16:49:55.000Z">
<meta property="article:modified_time" content="2024-12-08T05:17:30.721Z">
<meta property="article:author" content="Ysmmm">
<meta property="article:tag" content="期末复习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yansmaoa.github.io/img/v2-1cb481e27656b14e14b2878d6c47e544_r.jpg"><link rel="shortcut icon" href="/img/jinke.png"><link rel="canonical" href="https://yansmaoa.github.io/2024/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A02/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构复习2',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-12-08 13:17:30'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/saierda.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/v2-1cb481e27656b14e14b2878d6c47e544_r.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Ysmmm的快乐小屋"><span class="site-name">Ysmmm的快乐小屋</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构复习2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-26T16:49:55.000Z" title="发表于 2024-11-27 00:49:55">2024-11-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-08T05:17:30.721Z" title="更新于 2024-12-08 13:17:30">2024-12-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>73分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构复习2"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="串-String"><a href="#串-String" class="headerlink" title="串(String)"></a>串(String)</h1><h2 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h2><blockquote>
<p>用到了string.h的一些操作，应该学学,上网搜一下就好了</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义字符串类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *str;  <span class="comment">// 动态分配的字符串内容</span></span><br><span class="line">    <span class="type">int</span> length; <span class="comment">// 当前字符串长度</span></span><br><span class="line">&#125; MyString;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化字符串</span></span><br><span class="line">MyString <span class="title function_">initString</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *source)</span> &#123;</span><br><span class="line">    MyString s;</span><br><span class="line">    s.length = <span class="built_in">strlen</span>(source);</span><br><span class="line">    s.str = (<span class="type">char</span> *)<span class="built_in">malloc</span>((s.length + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="built_in">strcpy</span>(s.str, source);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyString</span><span class="params">(MyString *s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;str) &#123;</span><br><span class="line">        <span class="built_in">free</span>(s-&gt;str);</span><br><span class="line">        s-&gt;str = <span class="literal">NULL</span>;</span><br><span class="line">        s-&gt;length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">assignString</span><span class="params">(MyString *s, <span class="type">const</span> <span class="type">char</span> *source)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;str) <span class="built_in">free</span>(s-&gt;str);</span><br><span class="line">    s-&gt;length = <span class="built_in">strlen</span>(source);</span><br><span class="line">    s-&gt;str = (<span class="type">char</span> *)<span class="built_in">malloc</span>((s-&gt;length + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="built_in">strcpy</span>(s-&gt;str, source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较字符串</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compareString</span><span class="params">(MyString s1, MyString s2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(s1.str, s2.str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求串长</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getStringLength</span><span class="params">(MyString s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 串联</span></span><br><span class="line">MyString <span class="title function_">concatString</span><span class="params">(MyString s1, MyString s2)</span> &#123;</span><br><span class="line">    MyString result;</span><br><span class="line">    result.length = s1.length + s2.length;</span><br><span class="line">    result.str = (<span class="type">char</span> *)<span class="built_in">malloc</span>((result.length + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="built_in">strcpy</span>(result.str, s1.str);</span><br><span class="line">    <span class="built_in">strcat</span>(result.str, s2.str);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求子串</span></span><br><span class="line">MyString <span class="title function_">substring</span><span class="params">(MyString s, <span class="type">int</span> pos, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    MyString sub;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span> || pos &gt;= s.length || len &lt;= <span class="number">0</span> || pos + len &gt; s.length) &#123;</span><br><span class="line">        sub.str = <span class="literal">NULL</span>;</span><br><span class="line">        sub.length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sub;</span><br><span class="line">    &#125;</span><br><span class="line">    sub.length = len;</span><br><span class="line">    sub.str = (<span class="type">char</span> *)<span class="built_in">malloc</span>((len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="built_in">strncpy</span>(sub.str, s.str + pos, len);</span><br><span class="line">    sub.str[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> sub;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(MyString s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearString</span><span class="params">(MyString *s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;str) &#123;</span><br><span class="line">        <span class="built_in">free</span>(s-&gt;str);</span><br><span class="line">        s-&gt;str = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子串的位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findSubstring</span><span class="params">(MyString s, MyString sub)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *pos = <span class="built_in">strstr</span>(s.str, sub.str);</span><br><span class="line">    <span class="keyword">return</span> pos ? (<span class="type">int</span>)(pos - s.str) : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换子串</span></span><br><span class="line">MyString <span class="title function_">replaceSubstring</span><span class="params">(MyString s, MyString oldSub, MyString newSub)</span> &#123;</span><br><span class="line">    MyString result = initString(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    <span class="keyword">while</span> ((pos = findSubstring(s, oldSub)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        MyString left = substring(s, <span class="number">0</span>, pos);</span><br><span class="line">        MyString right = substring(s, pos + oldSub.length, s.length - pos - oldSub.length);</span><br><span class="line">        MyString temp = concatString(left, newSub);</span><br><span class="line">        destroyString(&amp;left);</span><br><span class="line">        destroyString(&amp;s);</span><br><span class="line">        s = concatString(temp, right);</span><br><span class="line">        destroyString(&amp;temp);</span><br><span class="line">        destroyString(&amp;right);</span><br><span class="line">    &#125;</span><br><span class="line">    result = s;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入子串</span></span><br><span class="line">MyString <span class="title function_">insertSubstring</span><span class="params">(MyString s, <span class="type">int</span> pos, MyString sub)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span> || pos &gt; s.length) <span class="keyword">return</span> s;</span><br><span class="line">    MyString left = substring(s, <span class="number">0</span>, pos);</span><br><span class="line">    MyString right = substring(s, pos, s.length - pos);</span><br><span class="line">    MyString temp = concatString(left, sub);</span><br><span class="line">    MyString result = concatString(temp, right);</span><br><span class="line">    destroyString(&amp;left);</span><br><span class="line">    destroyString(&amp;right);</span><br><span class="line">    destroyString(&amp;temp);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除子串</span></span><br><span class="line">MyString <span class="title function_">deleteSubstring</span><span class="params">(MyString s, <span class="type">int</span> pos, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span> || pos &gt;= s.length || len &lt;= <span class="number">0</span> || pos + len &gt; s.length) <span class="keyword">return</span> s;</span><br><span class="line">    MyString left = substring(s, <span class="number">0</span>, pos);</span><br><span class="line">    MyString right = substring(s, pos + len, s.length - pos - len);</span><br><span class="line">    MyString result = concatString(left, right);</span><br><span class="line">    destroyString(&amp;left);</span><br><span class="line">    destroyString(&amp;right);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例程序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyString s1 = initString(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    MyString s2 = initString(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">    MyString s3 = concatString(s1, s2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Concat: %s\n&quot;</span>, s3.str);</span><br><span class="line"></span><br><span class="line">    MyString sub = substring(s3, <span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Substring: %s\n&quot;</span>, sub.str);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pos = findSubstring(s3, initString(<span class="string">&quot;World&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Find position: %d\n&quot;</span>, pos);</span><br><span class="line"></span><br><span class="line">    MyString replaced = replaceSubstring(s3, initString(<span class="string">&quot;World&quot;</span>), initString(<span class="string">&quot;Everyone&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Replaced: %s\n&quot;</span>, replaced.str);</span><br><span class="line"></span><br><span class="line">    destroyString(&amp;s1);</span><br><span class="line">    destroyString(&amp;s2);</span><br><span class="line">    destroyString(&amp;s3);</span><br><span class="line">    destroyString(&amp;sub);</span><br><span class="line">    destroyString(&amp;replaced);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><ol>
<li>构建部分匹配表<ul>
<li>部分匹配值 是模式串中每个位置的前缀与后缀的最大匹配长度。</li>
<li>构建 next 数组，用于指示在模式串失配后，主串的比较位置可以跳转的地方，从而减少重复比较。</li>
</ul>
</li>
<li>匹配主串与模式串<ul>
<li>遍历主串时，如果字符匹配，则继续比较。</li>
<li>如果字符失配，则根据 next 数组跳转模式串的匹配起点，而不是回退主串指针。<br>kmp还是很难的，也很难去描述，建议【最浅显易懂的 KMP 算法讲解-哔哩哔哩】 <a target="_blank" rel="noopener" href="https://b23.tv/To4ex7N">https://b23.tv/To4ex7N</a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建 next 数组（部分匹配表）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">buildNext</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pattern, <span class="type">int</span> *next, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// 当前匹配的前缀长度</span></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 第一个字符的部分匹配值为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果前后缀不匹配，回退到上一个匹配的位置</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; pattern[i] != pattern[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果前后缀匹配，前缀长度加 1</span></span><br><span class="line">        <span class="keyword">if</span> (pattern[i] == pattern[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP 主算法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kmpSearch</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *text, <span class="type">const</span> <span class="type">char</span> *pattern)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(text);    <span class="comment">// 主串长度</span></span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(pattern); <span class="comment">// 模式串长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态分配 next 数组</span></span><br><span class="line">    <span class="type">int</span> *next = (<span class="type">int</span> *)<span class="built_in">malloc</span>(m * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    buildNext(pattern, next, m);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// 模式串指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 当字符失配时，根据 next 数组调整模式串位置</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; text[i] != pattern[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果字符匹配，模式串指针加 1</span></span><br><span class="line">        <span class="keyword">if</span> (text[i] == pattern[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果整个模式串匹配成功，返回匹配的起始位置</span></span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="built_in">free</span>(next); <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(next); <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 没有找到匹配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例程序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *text = <span class="string">&quot;ababcabcacbab&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pattern = <span class="string">&quot;abcac&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> position = kmpSearch(text, pattern);</span><br><span class="line">    <span class="keyword">if</span> (position != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Pattern found at index %d\n&quot;</span>, position);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Pattern not found.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
KMP算法的时间复杂度O(n + m)</li>
</ul>
</li>
</ol>
<h1 id="数组和广义表"><a href="#数组和广义表" class="headerlink" title="数组和广义表"></a>数组和广义表</h1><p>考概念居多，没代码实现，建议去看PPT</p>
<h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><blockquote>
<p>树的定义<br>树是由 n (n≥ 0) 个结点组成的有限集合。<br>如果n&#x3D; 0，称为空树；<br>否则，在一棵非空树中(n&gt;0) ，满足如下两个条件：<br>(1)有且仅有一个特定的称之为**根(root)<strong>的结点，它只有直接后继，但没有直接前驱；<br>(2)除根以外的其它结点划分为 m (m ≥ 0) 个互不相 交的有限集合 T0,T1, …, Tm-1，每个集合又是一棵树，并且称之为根的</strong>子树(subTree)**。</p>
</blockquote>
<ol>
<li><strong>根结点</strong>: 非空树中无前驱结点的节点</li>
<li>结点的<strong>度(degree)</strong>: 结点拥有的子树数</li>
<li>&#x2F;叶子&#x2F;终端结点: 度&#x3D;0分支结点&#x2F;非终端结点: 度≠0</li>
<li>部结点: 根结点以外的分支结点结点的子树的根称为该节点的<strong>孩子(Child)<strong>，该结点称为孩子的</strong>双亲(Parent)</strong></li>
<li>同一双亲的孩子之间互称<strong>兄弟(Sibling)</strong></li>
<li>树的<strong>深度(高度)</strong>: 树中结点的最大层次</li>
</ol>
<p>建议学好递归再来学树</p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p><strong>哈夫曼编码的一个重要性质是无前缀性质（Prefix Property），即任何字符的编码都不会是其他字符编码的前缀。</strong><br>具体来说，哈夫曼树的路径保证了任何一个字符的编码不会是另一个字符编码的前缀。这是通过树的结构保证的：每个字符的编码对应哈夫曼树中从根到叶子的路径。由于我们构建树时，频率较高的字符更靠近根节点，因此它们的编码长度较短，而频率较低的字符的编码则较长。<br>只要是叶子就不会是其他编码的前缀或者是后缀<br>数据压缩编码<br>其实就是实现没有公共前缀的01二进制编码来优化存储空间<br>A	5<br>B	9<br>C	12<br>D	13<br>E	16<br>F	45<br>构建过程：<br>将权值最小的两个节点 A(5) 和 B(9) 合并为新节点 T1(14)。<br>将 T1(14) 和 C(12) 合并为新节点 T2(26)。<br>将 T2(26) 和 D(13) 合并为新节点 T3(39)。<br>将 T3(39) 和 E(16) 合并为新节点 T4(55)。<br>将 T4(55) 和 F(45) 合并为根节点 T5(100)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      [<span class="number">100</span>]</span><br><span class="line">     /     \</span><br><span class="line">  [<span class="number">45</span>]     [<span class="number">55</span>]</span><br><span class="line">          /     \</span><br><span class="line">       [<span class="number">26</span>]     [<span class="number">16</span>]</span><br><span class="line">      /    \</span><br><span class="line">   [<span class="number">14</span>]    [<span class="number">12</span>]</span><br><span class="line">  /   \</span><br><span class="line">[<span class="number">5</span>]   [<span class="number">9</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>很喜欢用堆去解释这些东西，堆可以理解成每次在一个集合中取最大或者最小的元素，也可以放入元素进入集合<br>利用堆去实现的效率会高很多，很轻松的去实现，先放这里，看不懂算了，学会理论就好了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈夫曼树节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HuffmanNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data;            <span class="comment">// 字符</span></span><br><span class="line">    <span class="type">int</span> weight;           <span class="comment">// 权值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HuffmanNode</span> *<span class="title">left</span>, *<span class="title">right</span>;</span> <span class="comment">// 左右子节点</span></span><br><span class="line">&#125; HuffmanNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小堆结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MinHeap</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;             <span class="comment">// 当前堆大小</span></span><br><span class="line">    <span class="type">int</span> capacity;         <span class="comment">// 堆容量</span></span><br><span class="line">    HuffmanNode **<span class="built_in">array</span>;  <span class="comment">// 存放节点的指针数组</span></span><br><span class="line">&#125; MinHeap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新节点</span></span><br><span class="line">HuffmanNode *<span class="title function_">createNode</span><span class="params">(<span class="type">char</span> data, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">    HuffmanNode *node = (HuffmanNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HuffmanNode));</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    node-&gt;weight = weight;</span><br><span class="line">    node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个最小堆</span></span><br><span class="line">MinHeap *<span class="title function_">createMinHeap</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    MinHeap *heap = (MinHeap *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MinHeap));</span><br><span class="line">    heap-&gt;size = <span class="number">0</span>;</span><br><span class="line">    heap-&gt;capacity = capacity;</span><br><span class="line">    heap-&gt;<span class="built_in">array</span> = (HuffmanNode **)<span class="built_in">malloc</span>(capacity * <span class="keyword">sizeof</span>(HuffmanNode *));</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个堆节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swapNodes</span><span class="params">(HuffmanNode **a, HuffmanNode **b)</span> &#123;</span><br><span class="line">    HuffmanNode *temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆化调整</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">minHeapify</span><span class="params">(MinHeap *heap, <span class="type">int</span> idx)</span> &#123;</span><br><span class="line">    <span class="type">int</span> smallest = idx;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * idx + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * idx + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; heap-&gt;size &amp;&amp; heap-&gt;<span class="built_in">array</span>[left]-&gt;weight &lt; heap-&gt;<span class="built_in">array</span>[smallest]-&gt;weight)</span><br><span class="line">        smallest = left;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; heap-&gt;size &amp;&amp; heap-&gt;<span class="built_in">array</span>[right]-&gt;weight &lt; heap-&gt;<span class="built_in">array</span>[smallest]-&gt;weight)</span><br><span class="line">        smallest = right;</span><br><span class="line">    <span class="keyword">if</span> (smallest != idx) &#123;</span><br><span class="line">        swapNodes(&amp;heap-&gt;<span class="built_in">array</span>[smallest], &amp;heap-&gt;<span class="built_in">array</span>[idx]);</span><br><span class="line">        minHeapify(heap, smallest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取堆中最小节点</span></span><br><span class="line">HuffmanNode *<span class="title function_">extractMin</span><span class="params">(MinHeap *heap)</span> &#123;</span><br><span class="line">    HuffmanNode *temp = heap-&gt;<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    heap-&gt;<span class="built_in">array</span>[<span class="number">0</span>] = heap-&gt;<span class="built_in">array</span>[heap-&gt;size - <span class="number">1</span>];</span><br><span class="line">    heap-&gt;size--;</span><br><span class="line">    minHeapify(heap, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向堆中插入节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertMinHeap</span><span class="params">(MinHeap *heap, HuffmanNode *node)</span> &#123;</span><br><span class="line">    heap-&gt;size++;</span><br><span class="line">    <span class="type">int</span> i = heap-&gt;size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; node-&gt;weight &lt; heap-&gt;<span class="built_in">array</span>[(i - <span class="number">1</span>) / <span class="number">2</span>]-&gt;weight) &#123;</span><br><span class="line">        heap-&gt;<span class="built_in">array</span>[i] = heap-&gt;<span class="built_in">array</span>[(i - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">        i = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heap-&gt;<span class="built_in">array</span>[i] = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建最小堆</span></span><br><span class="line">MinHeap *<span class="title function_">buildMinHeap</span><span class="params">(<span class="type">char</span> data[], <span class="type">int</span> weight[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    MinHeap *heap = createMinHeap(size);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        heap-&gt;<span class="built_in">array</span>[i] = createNode(data[i], weight[i]);</span><br><span class="line">    heap-&gt;size = size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (size - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        minHeapify(heap, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建哈夫曼树</span></span><br><span class="line">HuffmanNode *<span class="title function_">buildHuffmanTree</span><span class="params">(<span class="type">char</span> data[], <span class="type">int</span> weight[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    MinHeap *heap = buildMinHeap(data, weight, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap-&gt;size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        HuffmanNode *left = extractMin(heap);</span><br><span class="line">        HuffmanNode *right = extractMin(heap);</span><br><span class="line"></span><br><span class="line">        HuffmanNode *top = createNode(<span class="string">&#x27;$&#x27;</span>, left-&gt;weight + right-&gt;weight);</span><br><span class="line">        top-&gt;left = left;</span><br><span class="line">        top-&gt;right = right;</span><br><span class="line"></span><br><span class="line">        insertMinHeap(heap, top);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> extractMin(heap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印哈夫曼编码（前序遍历）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printCodes</span><span class="params">(HuffmanNode *root, <span class="type">int</span> *code, <span class="type">int</span> top)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">        code[top] = <span class="number">0</span>;</span><br><span class="line">        printCodes(root-&gt;left, code, top + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">        code[top] = <span class="number">1</span>;</span><br><span class="line">        printCodes(root-&gt;right, code, top + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c: &quot;</span>, root-&gt;data);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; top; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, code[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> data[] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> weight[] = &#123;<span class="number">5</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">45</span>&#125;;</span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(data) / <span class="keyword">sizeof</span>(data[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    HuffmanNode *root = buildHuffmanTree(data, weight, size);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> code[<span class="number">100</span>], top = <span class="number">0</span>;</span><br><span class="line">    printCodes(root, code, top);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>F: 0<br>C: 100<br>A: 1010<br>B: 1011<br>D: 110<br>E: 111<br>再贴上一个书上用遍历去实现的哈夫曼树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100  <span class="comment">// 最大树节点数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义哈夫曼树的节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HuffmanNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data;           <span class="comment">// 节点代表的字符</span></span><br><span class="line">    <span class="type">int</span> frequency;       <span class="comment">// 字符的频率</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HuffmanNode</span>* <span class="title">left</span>;</span>  <span class="comment">// 左子树</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HuffmanNode</span>* <span class="title">right</span>;</span> <span class="comment">// 右子树</span></span><br><span class="line">&#125; HuffmanNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的哈夫曼树节点</span></span><br><span class="line">HuffmanNode* <span class="title function_">createHuffmanNode</span><span class="params">(<span class="type">char</span> data, <span class="type">int</span> frequency)</span> &#123;</span><br><span class="line">    HuffmanNode* node = (HuffmanNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HuffmanNode));</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    node-&gt;frequency = frequency;</span><br><span class="line">    node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个节点的频率，返回频率较小的节点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compareNodes</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((HuffmanNode*)a)-&gt;frequency - ((HuffmanNode*)b)-&gt;frequency;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建哈夫曼树</span></span><br><span class="line">HuffmanNode* <span class="title function_">buildHuffmanTree</span><span class="params">(<span class="type">char</span>* data, <span class="type">int</span>* freq, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个包含所有字符节点的数组</span></span><br><span class="line">    HuffmanNode* nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        nodes[i] = createHuffmanNode(data[i], freq[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用遍历的方式替代堆</span></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 每次遍历数组，找到频率最小的两个节点</span></span><br><span class="line">        qsort(nodes, n, <span class="keyword">sizeof</span>(HuffmanNode*), compareNodes);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 取出最小的两个节点</span></span><br><span class="line">        HuffmanNode* left = nodes[<span class="number">0</span>];</span><br><span class="line">        HuffmanNode* right = nodes[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个新节点，其频率为左右子树频率之和</span></span><br><span class="line">        HuffmanNode* newNode = createHuffmanNode(<span class="string">&#x27;\0&#x27;</span>, left-&gt;frequency + right-&gt;frequency);</span><br><span class="line">        newNode-&gt;left = left;</span><br><span class="line">        newNode-&gt;right = right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将新节点插入数组并调整数组</span></span><br><span class="line">        nodes[<span class="number">0</span>] = newNode;</span><br><span class="line">        <span class="comment">// 将其他节点向前移动一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            nodes[i] = nodes[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n--;  <span class="comment">// 节点数量减一</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回哈夫曼树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> nodes[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印哈夫曼树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printHuffmanTree</span><span class="params">(HuffmanNode* root, <span class="type">char</span>* code, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是叶子节点，打印其字符和对应的编码</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        code[length] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 结束编码字符串</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c: %s\n&quot;</span>, root-&gt;data, code);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向左子树递归添加&#x27;0&#x27;</span></span><br><span class="line">    code[length] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    printHuffmanTree(root-&gt;left, code, length + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向右子树递归添加&#x27;1&#x27;</span></span><br><span class="line">    code[length] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    printHuffmanTree(root-&gt;right, code, length + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 输入字符和频率</span></span><br><span class="line">    <span class="type">char</span> data[] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> freq[] = &#123;<span class="number">5</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">45</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(data) / <span class="keyword">sizeof</span>(data[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建哈夫曼树</span></span><br><span class="line">    HuffmanNode* root = buildHuffmanTree(data, freq, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印哈夫曼编码</span></span><br><span class="line">    <span class="type">char</span> code[MAX_TREE_SIZE];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Huffman Codes:\n&quot;</span>);</span><br><span class="line">    printHuffmanTree(root, code, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="满二叉树-和-完全二叉树"><a href="#满二叉树-和-完全二叉树" class="headerlink" title="满二叉树 和 完全二叉树"></a>满二叉树 和 完全二叉树</h3><ol>
<li><p>满二叉树<br>一个二叉树如果所有层上的结点数都达到了最大值，则称为满二叉树。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">1</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">3</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">4</span>   <span class="number">5</span> <span class="number">6</span>   <span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>完全二叉树<br>一个二叉树如果其所有层（除了最后一层）都完全填满，并且最后一层的结点都靠左排列，则称为完全二叉树。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">1</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">3</span></span><br><span class="line"> / \   / </span><br><span class="line"><span class="number">4</span>   <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="树的建立，遍历"><a href="#树的建立，遍历" class="headerlink" title="树的建立，遍历"></a>树的建立，遍历</h3><p>我认为看代码更能理解怎么前中后遍历</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;                     <span class="comment">// 节点值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span>        <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span>       <span class="comment">// 右子节点</span></span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新节点</span></span><br><span class="line">TreeNode *<span class="title function_">createNode</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    TreeNode *newNode = (TreeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    newNode-&gt;data = value;</span><br><span class="line">    newNode-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建二叉树 (递归输入)</span></span><br><span class="line">TreeNode *<span class="title function_">buildTree</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入节点值(-1表示为空)：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果输入为 -1，返回空节点</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建根节点</span></span><br><span class="line">    TreeNode *root = createNode(value);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入 %d 的左子节点：\n&quot;</span>, value);</span><br><span class="line">    root-&gt;left = buildTree();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入 %d 的右子节点：\n&quot;</span>, value);</span><br><span class="line">    root-&gt;right = buildTree();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode *root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);  <span class="comment">// 访问根节点</span></span><br><span class="line">    preOrder(root-&gt;left);      <span class="comment">// 遍历左子树</span></span><br><span class="line">    preOrder(root-&gt;right);     <span class="comment">// 遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode *root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrder(root-&gt;left);       <span class="comment">// 遍历左子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data); <span class="comment">// 访问根节点</span></span><br><span class="line">    inOrder(root-&gt;right);      <span class="comment">// 遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode *root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrder(root-&gt;left);     <span class="comment">// 遍历左子树</span></span><br><span class="line">    postOrder(root-&gt;right);    <span class="comment">// 遍历右子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data); <span class="comment">// 访问根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放二叉树内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeTree</span><span class="params">(TreeNode *root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    freeTree(root-&gt;left);  <span class="comment">// 释放左子树</span></span><br><span class="line">    freeTree(root-&gt;right); <span class="comment">// 释放右子树</span></span><br><span class="line">    <span class="built_in">free</span>(root);            <span class="comment">// 释放当前节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始构建二叉树...\n&quot;</span>);</span><br><span class="line">    TreeNode *root = buildTree();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n前序遍历结果：&quot;</span>);</span><br><span class="line">    preOrder(root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n中序遍历结果：&quot;</span>);</span><br><span class="line">    inOrder(root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n后序遍历结果：&quot;</span>);</span><br><span class="line">    postOrder(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    freeTree(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">4</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>前序遍历结果：1 2 3 4<br>中序遍历结果：2 3 1 4<br>后序遍历结果：3 2 4 1</p>
<p>要想确定树的样子一定要有中序遍历，然后去根据定义一递归的去找左右就好了<br>多练习两个看看就好了<br>示例<br>假设：<br>前序遍历：A B D E C F G<br>中序遍历：D B E A F C G<br>构建过程：<br>从前序遍历中，A 是根节点。<br>在中序遍历中，A 将序列分为两部分：<br>左子树的中序序列：D B E<br>右子树的中序序列：F C G<br>从前序遍历的剩余部分：<br>左子树的前序序列：B D E<br>右子树的前序序列：C F G<br>递归构建左右子树：<br>左子树的根节点是 B。<br>右子树的根节点是 C。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   / \</span><br><span class="line">  B   C</span><br><span class="line"> / \   \</span><br><span class="line">D   E   F</span><br><span class="line">         \</span><br><span class="line">          G</span><br></pre></td></tr></table></figure>
<p>中序遍历是分割子树的关键，前序或后序遍历提供了根节点的顺序。</p>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>是一种对普通二叉树的扩展。通过利用二叉树中指针的空闲空间，将树中节点的左右指针扩展为指向前驱节点和后继节点，使遍历树更加高效。<br>就是可以不每一次从头节点开始遍历<br>前序线索二叉树：基于前序遍历建立的线索二叉树。<br>中序线索二叉树：基于中序遍历建立的线索二叉树。<br>后序线索二叉树：基于后序遍历建立的线索二叉树。<br><strong>特点</strong><br>线索二叉树在节点结构中新增了两个布尔变量，用来标记左右指针是否是线索：<br>LTag：标记左指针的含义，0 表示指向左子树，1 表示指向前驱。<br>RTag：标记右指针的含义，0 表示指向右子树，1 表示指向后继。<br>线索二叉树通过线索化处理后，可以通过线索指针快速找到前驱和后继节点，而无需递归或栈辅助。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义线索二叉树节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadedTreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadedTreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadedTreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="type">int</span> LTag; <span class="comment">// 0: 左指针指向子树, 1: 左指针为线索</span></span><br><span class="line">    <span class="type">int</span> RTag; <span class="comment">// 0: 右指针指向子树, 1: 右指针为线索</span></span><br><span class="line">&#125; ThreadedTreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量，用来记录当前节点的前驱节点</span></span><br><span class="line">ThreadedTreeNode *pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新节点</span></span><br><span class="line">ThreadedTreeNode *<span class="title function_">createNode</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    ThreadedTreeNode *node = (ThreadedTreeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ThreadedTreeNode));</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;LTag = <span class="number">0</span>;</span><br><span class="line">    node-&gt;RTag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inThreading</span><span class="params">(ThreadedTreeNode *root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线索化左子树</span></span><br><span class="line">    inThreading(root-&gt;left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左指针为空，将其指向前驱</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root-&gt;LTag = <span class="number">1</span>;</span><br><span class="line">        root-&gt;left = pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前驱节点的右指针为空，将其指向当前节点</span></span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pre-&gt;RTag = <span class="number">1</span>;</span><br><span class="line">        pre-&gt;right = root;</span><br><span class="line">    &#125;<span class="comment">// 重点注意这个地方，虽然很难但是很关键</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新前驱节点为当前节点</span></span><br><span class="line">    pre = root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线索化右子树</span></span><br><span class="line">    inThreading(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线索二叉树</span></span><br><span class="line">ThreadedTreeNode *<span class="title function_">createThreadedTree</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 构造普通二叉树</span></span><br><span class="line">    ThreadedTreeNode *root = createNode(<span class="number">1</span>);</span><br><span class="line">    root-&gt;left = createNode(<span class="number">2</span>);</span><br><span class="line">    root-&gt;right = createNode(<span class="number">3</span>);</span><br><span class="line">    root-&gt;left-&gt;left = createNode(<span class="number">4</span>);</span><br><span class="line">    root-&gt;left-&gt;right = createNode(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线索化</span></span><br><span class="line">    pre = <span class="literal">NULL</span>;</span><br><span class="line">    inThreading(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历线索二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrderTraverse</span><span class="params">(ThreadedTreeNode *root)</span> &#123;</span><br><span class="line">    ThreadedTreeNode *current = root;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到最左侧的节点</span></span><br><span class="line">        <span class="keyword">while</span> (current-&gt;LTag == <span class="number">0</span>) &#123;</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印当前节点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用线索访问后继节点</span></span><br><span class="line">        <span class="keyword">while</span> (current-&gt;RTag == <span class="number">1</span>) &#123;</span><br><span class="line">            current = current-&gt;right;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转向右子树</span></span><br><span class="line">        current = current-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    ThreadedTreeNode *root = createThreadedTree();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;中序遍历线索二叉树：&quot;</span>);</span><br><span class="line">    inOrderTraverse(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实和三种遍历一样，改改遍历顺序就好了</p>
<h3 id="森林与树与二叉树的转换"><a href="#森林与树与二叉树的转换" class="headerlink" title="森林与树与二叉树的转换"></a>森林与树与二叉树的转换</h3><p>感觉没啥用，自己去看ppt<br>技巧：</p>
<ol>
<li>将树转换成二叉树 ：兄弟相连留长子</li>
<li>二叉树变树：左孩右右连双亲，去掉原来右孩线</li>
<li>森林变二叉树：树变二叉根相连</li>
<li>二叉树变森林：去掉全部右孩线，孤立二叉再还原 &#x2F;&#x2F; 主要是树和森林怎么变<br>代码实现巨麻烦，我就贴一个看看就好了<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义N叉树节点（普通树节点）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NTreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data;              <span class="comment">// 数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NTreeNode</span> **<span class="title">children</span>;</span> <span class="comment">// 子节点数组</span></span><br><span class="line">    <span class="type">int</span> child_count;        <span class="comment">// 子节点数目</span></span><br><span class="line">&#125; NTreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data;              <span class="comment">// 数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span> *<span class="title">left</span>;</span>   <span class="comment">// 左子节点（第一个子节点）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span> *<span class="title">right</span>;</span>  <span class="comment">// 右子节点（下一个兄弟节点）</span></span><br><span class="line">&#125; BinaryTreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个N叉树节点</span></span><br><span class="line">NTreeNode* <span class="title function_">createNTreeNode</span><span class="params">(<span class="type">char</span> data, <span class="type">int</span> child_count)</span> &#123;</span><br><span class="line">    NTreeNode* node = (NTreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NTreeNode));</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    node-&gt;child_count = child_count;</span><br><span class="line">    node-&gt;children = (NTreeNode**)<span class="built_in">malloc</span>(child_count * <span class="keyword">sizeof</span>(NTreeNode*));</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个二叉树节点</span></span><br><span class="line">BinaryTreeNode* <span class="title function_">createBinaryTreeNode</span><span class="params">(<span class="type">char</span> data)</span> &#123;</span><br><span class="line">    BinaryTreeNode* node = (BinaryTreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BinaryTreeNode));</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// N叉树转二叉树</span></span><br><span class="line">BinaryTreeNode* <span class="title function_">NTreeToBinaryTree</span><span class="params">(NTreeNode* nNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nNode == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个对应的二叉树节点</span></span><br><span class="line">    BinaryTreeNode* bNode = createBinaryTreeNode(nNode-&gt;data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理第一个子节点，作为左子节点</span></span><br><span class="line">    <span class="keyword">if</span> (nNode-&gt;child_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        bNode-&gt;left = NTreeToBinaryTree(nNode-&gt;children[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理剩余的子节点，作为右子节点链表</span></span><br><span class="line">    BinaryTreeNode* current = bNode-&gt;left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nNode-&gt;child_count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            current = NTreeToBinaryTree(nNode-&gt;children[i]);</span><br><span class="line">            bNode-&gt;left = current;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current-&gt;right = NTreeToBinaryTree(nNode-&gt;children[i]);</span><br><span class="line">            current = current-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树转N叉树</span></span><br><span class="line">NTreeNode* <span class="title function_">BinaryTreeToNTree</span><span class="params">(BinaryTreeNode* bNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bNode == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个对应的N叉树节点</span></span><br><span class="line">    NTreeNode* nNode = createNTreeNode(bNode-&gt;data, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理左子树（第一个子节点）</span></span><br><span class="line">    <span class="keyword">if</span> (bNode-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        NTreeNode* leftChild = BinaryTreeToNTree(bNode-&gt;left);</span><br><span class="line">        nNode-&gt;children = (NTreeNode**)<span class="built_in">realloc</span>(nNode-&gt;children, ++(nNode-&gt;child_count) * <span class="keyword">sizeof</span>(NTreeNode*));</span><br><span class="line">        nNode-&gt;children[nNode-&gt;child_count - <span class="number">1</span>] = leftChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理右子树（兄弟节点）</span></span><br><span class="line">    BinaryTreeNode* sibling = bNode-&gt;right;</span><br><span class="line">    <span class="keyword">while</span> (sibling != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        NTreeNode* rightSibling = BinaryTreeToNTree(sibling);</span><br><span class="line">        nNode-&gt;children = (NTreeNode**)<span class="built_in">realloc</span>(nNode-&gt;children, ++(nNode-&gt;child_count) * <span class="keyword">sizeof</span>(NTreeNode*));</span><br><span class="line">        nNode-&gt;children[nNode-&gt;child_count - <span class="number">1</span>] = rightSibling;</span><br><span class="line">        sibling = sibling-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printBinaryTreePreorder</span><span class="params">(BinaryTreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;data);</span><br><span class="line">    printBinaryTreePreorder(root-&gt;left);</span><br><span class="line">    printBinaryTreePreorder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印N叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printNTree</span><span class="params">(NTreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;data);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; root-&gt;child_count; i++) &#123;</span><br><span class="line">        printNTree(root-&gt;children[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个N叉树</span></span><br><span class="line">    NTreeNode* nRoot = createNTreeNode(<span class="string">&#x27;A&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">    nRoot-&gt;children[<span class="number">0</span>] = createNTreeNode(<span class="string">&#x27;B&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">    nRoot-&gt;children[<span class="number">1</span>] = createNTreeNode(<span class="string">&#x27;C&#x27;</span>, <span class="number">0</span>);</span><br><span class="line">    nRoot-&gt;children[<span class="number">2</span>] = createNTreeNode(<span class="string">&#x27;D&#x27;</span>, <span class="number">0</span>);</span><br><span class="line">    nRoot-&gt;children[<span class="number">0</span>]-&gt;children[<span class="number">0</span>] = createNTreeNode(<span class="string">&#x27;E&#x27;</span>, <span class="number">0</span>);</span><br><span class="line">    nRoot-&gt;children[<span class="number">0</span>]-&gt;children[<span class="number">1</span>] = createNTreeNode(<span class="string">&#x27;F&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将N叉树转换为二叉树</span></span><br><span class="line">    BinaryTreeNode* bRoot = NTreeToBinaryTree(nRoot);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印二叉树（前序遍历）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Binary Tree (Preorder): &quot;</span>);</span><br><span class="line">    printBinaryTreePreorder(bRoot);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将二叉树转换回N叉树</span></span><br><span class="line">    NTreeNode* newNRoot = BinaryTreeToNTree(bRoot);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印N叉树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;N Tree: &quot;</span>);</span><br><span class="line">    printNTree(newNRoot);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>图: G &#x3D; (V, E)<br>V: 顶点（Vertex）的有穷非空集合; 顶点表示数据元素<br>E: 边（Edge，或称弧Arc）的有穷集合;<br>边表示数据元素之间的关系</p>
<p>G1&#x3D;&lt;V1,E1&gt;<br>V1&#x3D;{v1 v2,v3,v4}<br>E1&#x3D;{&lt;v1,v2 &gt;,&lt;v1,v3 &gt;,&lt;v3,v4 &gt;,&lt;v4,v1 &gt;}</p>
<ol>
<li>无向图(Directed Graph, or Digraph): 每条边都是无方向的;</li>
<li>有向图(Undirected Graph, or Undigraph): 每条边都是有方向的。</li>
</ol>
<p>完全图(Completed Graph): 任意两个点都有一条边相连</p>
<ol>
<li><p>无向完全图：有n(n-1)&#x2F;2条边（图中每个顶点和其余n-1个顶点都有边相连）的无向图为完全图。</p>
</li>
<li><p>有向完全图：有n(n-1)条边（图中每个顶点和其余n-1个顶点都有弧相连）的有向图为有向完全图。</p>
</li>
<li><p>稀疏图(Sparse Graph): 有很少边或弧的图（e &lt; n log n）</p>
</li>
<li><p>稠密图(Dense Graph): 有较多边或弧的图</p>
</li>
</ol>
<p>邻接: 有边&#x2F;弧相连的两个顶点之间的关系</p>
<ol>
<li>无向图: 存在边(v, v’), 称作v与v’互为邻接点(Adjacent)，即v与v’相邻接; 边(v, v’)依附于(Incident)顶点v和v’ , 或者说(v, v’)与顶点v和v’ 相关联</li>
<li>有向图: 存在边&lt; v, v’&gt; ，则称顶点v邻接到顶点v’，顶点v’邻接自顶点v ，或者说弧&lt; v, v’&gt;与顶点v、v’相关联。</li>
</ol>
<p>顶点的度(Degree):</p>
<ol>
<li>对无向图而言，顶点v 的度是指和v相关联的边的数目，记作TD(v)</li>
<li>对有向图而言，顶点v的度是其入度和出度之和<br>• 入度(Indegree): 以v为终点的有向边的条数，记作ID(v)<br>• 出度(Outdegree): 以v为始点的有向边的条数，记作OD(v)<br>• TD(v) &#x3D; ID(v) + OD(v)</li>
</ol>
<p>路径(Path): 接续的边构成的顶点序列</p>
<ol>
<li>对无向图而言，从顶点v到v’的路径是一个顶点序列(v&#x3D;vi0, vi1, vi2, …,vim&#x3D; v ’), 其中(vij-1, vij)∈E, 1≤j≤m。</li>
<li>对有向图而言，路径也是有向的，顶点序列应满足&lt;vij-1, vij&gt;∈E，1≤j≤m。</li>
</ol>
<ul>
<li>路径长度: 路径上边或弧的数目&#x2F;权值之和</li>
<li>回路(环): 第一个顶点和最后一个顶点相同的路径</li>
<li>简单路径: 路径上顶点均不相同的路径</li>
<li>简单回路(简单环): 除路径起点和终点相同外，其余顶点均不相同的路径</li>
</ul>
<ol>
<li>连通图: 在无向图G&#x3D;（V，{E}）中，若从vi到vj有路径相通，则称顶点vi与vj是连通的。如果对于图中的任意两个顶点vi、vj∈V，vi与vj都是连通的，则称该无向图G为**连通图(Connected Graph)**。</li>
<li>强连通图：在有向图G&#x3D;（V，{A}）中，若对于每对顶点vi、vj∈V且vi≠vj，从vi到vj和vj到vi都有路径，则称该有向图为<strong>强连通图</strong></li>
</ol>
<p><strong>连通分量</strong>：无向图G中的极大连通子图称为G的连通分量(Connected Component)。<br>极大连通子图：该子图是G的连通子图，将G的任何不在该子<br>图中的顶点加入，子图不再连通。</p>
<p><strong>强连通分量</strong>：有向图的极大强连通子图称作有向图的强连通分量。<br>极大强连通子图：该子图是G的强连通子图，将D的任何不在子图中的顶点加入，子图不在是强连通的。</p>
<h2 id="实现建图，dfs-深度优先遍历-bfs-广度优先遍历"><a href="#实现建图，dfs-深度优先遍历-bfs-广度优先遍历" class="headerlink" title="实现建图，dfs(深度优先遍历), bfs(广度优先遍历)"></a>实现建图，dfs(深度优先遍历), bfs(广度优先遍历)</h2><ol>
<li>邻接表<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 图的邻接表表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> vertex;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> V;             <span class="comment">// 顶点数</span></span><br><span class="line">    Node** adjList;    <span class="comment">// 邻接表</span></span><br><span class="line">&#125; Graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个图</span></span><br><span class="line">Graph* <span class="title function_">createGraph</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">    Graph* graph = (Graph*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Graph));</span><br><span class="line">    graph-&gt;V = V;</span><br><span class="line">    graph-&gt;adjList = (Node**)<span class="built_in">malloc</span>(V * <span class="keyword">sizeof</span>(Node*));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化每个邻接表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">        graph-&gt;adjList[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加边到图中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addEdge</span><span class="params">(Graph* graph, <span class="type">int</span> src, <span class="type">int</span> dest)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加从src到dest的边</span></span><br><span class="line">    Node* newNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;vertex = dest;</span><br><span class="line">    newNode-&gt;next = graph-&gt;adjList[src];</span><br><span class="line">    graph-&gt;adjList[src] = newNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是无向图，也需要添加反向边</span></span><br><span class="line">    newNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;vertex = src;</span><br><span class="line">    newNode-&gt;next = graph-&gt;adjList[dest];</span><br><span class="line">    graph-&gt;adjList[dest] = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印图的邻接表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printGraph</span><span class="params">(Graph* graph)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; graph-&gt;V; v++) &#123;</span><br><span class="line">        Node* temp = graph-&gt;adjList[v];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nVertex %d: &quot;</span>, v);</span><br><span class="line">        <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, temp-&gt;vertex);</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS 广度优先搜索</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(Graph* graph, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* visited = (<span class="type">int</span>*)<span class="built_in">malloc</span>(graph-&gt;V * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;V; i++) &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个队列来实现BFS</span></span><br><span class="line">    <span class="type">int</span>* <span class="built_in">queue</span> = (<span class="type">int</span>*)<span class="built_in">malloc</span>(graph-&gt;V * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问起始节点</span></span><br><span class="line">    visited[start] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">queue</span>[rear++] = start; <span class="comment">//数组模拟队列</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nBFS starting from vertex %d: &quot;</span>, start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (front &lt; rear) &#123;</span><br><span class="line">        <span class="type">int</span> vertex = <span class="built_in">queue</span>[front++];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, vertex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问与当前节点相邻的未访问节点</span></span><br><span class="line">        Node* temp = graph-&gt;adjList[vertex];</span><br><span class="line">        <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[temp-&gt;vertex]) &#123;</span><br><span class="line">                visited[temp-&gt;vertex] = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">queue</span>[rear++] = temp-&gt;vertex;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(visited);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS 深度优先搜索</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSUtil</span><span class="params">(Graph* graph, <span class="type">int</span> vertex, <span class="type">int</span>* visited)</span> &#123;</span><br><span class="line">    <span class="comment">// 访问当前节点</span></span><br><span class="line">    visited[vertex] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, vertex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归访问所有与当前节点相邻的未访问节点</span></span><br><span class="line">    Node* temp = graph-&gt;adjList[vertex];</span><br><span class="line">    <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[temp-&gt;vertex]) &#123;</span><br><span class="line">            DFSUtil(graph, temp-&gt;vertex, visited);</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph* graph, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* visited = (<span class="type">int</span>*)<span class="built_in">malloc</span>(graph-&gt;V * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;V; i++) &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nDFS starting from vertex %d: &quot;</span>, start);</span><br><span class="line">    DFSUtil(graph, start, visited);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个图并添加边</span></span><br><span class="line">    Graph* graph = createGraph(<span class="number">5</span>);</span><br><span class="line">    addEdge(graph, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    addEdge(graph, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    addEdge(graph, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    addEdge(graph, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    addEdge(graph, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    addEdge(graph, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    addEdge(graph, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印图的邻接表</span></span><br><span class="line">    printGraph(graph);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行BFS和DFS</span></span><br><span class="line">    BFS(graph, <span class="number">0</span>);  <span class="comment">// 从节点0开始BFS</span></span><br><span class="line">    DFS(graph, <span class="number">0</span>);  <span class="comment">// 从节点0开始DFS</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放图的内存</span></span><br><span class="line">    <span class="built_in">free</span>(graph-&gt;adjList);</span><br><span class="line">    <span class="built_in">free</span>(graph);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
临界表的好处是空间小，运行时间短，但是不好写<br> -&gt; 头节点 -&gt; 节点1 -&gt; 节点2 -&gt; 节点3 -&gt; NULL<br> -&gt; 新头节点(X) -&gt; 头节点 -&gt; 节点1 -&gt; 节点2 -&gt; 节点3 -&gt; NULL</li>
<li>邻接矩阵<br>邻接矩阵是一种二维数组，其中矩阵中的元素表示图中节点之间的连接关系。如果图中存在边，则对应矩阵位置为1，否则为0。对于无向图，矩阵是对称的。<br>假设我们有一个图，包含 4 个节点，边的连接如下：</li>
</ol>
<p>节点 0 与节点 1 和 2 有边。<br>节点 1 与节点 3 有边。<br>节点 2 与节点 3 有边。<br>这个图的邻接矩阵如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line">  --------------</span><br><span class="line"><span class="number">0</span> | <span class="number">0</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">0</span></span><br><span class="line"><span class="number">1</span> | <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span></span><br><span class="line"><span class="number">2</span> | <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span></span><br><span class="line"><span class="number">3</span> | <span class="number">0</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTICES 10  <span class="comment">// 最大顶点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 图的邻接矩阵表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> adjMatrix[MAX_VERTICES][MAX_VERTICES];  <span class="comment">// 邻接矩阵</span></span><br><span class="line">    <span class="type">int</span> V;  <span class="comment">// 图的顶点数</span></span><br><span class="line">&#125; Graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建图</span></span><br><span class="line">Graph* <span class="title function_">createGraph</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">    Graph* graph = (Graph*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Graph));</span><br><span class="line">    graph-&gt;V = V;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; V; j++) &#123;</span><br><span class="line">            graph-&gt;adjMatrix[i][j] = <span class="number">0</span>;  <span class="comment">// 初始时没有边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加边到图</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addEdge</span><span class="params">(Graph* graph, <span class="type">int</span> src, <span class="type">int</span> dest)</span> &#123;</span><br><span class="line">    graph-&gt;adjMatrix[src][dest] = <span class="number">1</span>;</span><br><span class="line">    graph-&gt;adjMatrix[dest][src] = <span class="number">1</span>;  <span class="comment">// 如果是无向图</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印邻接矩阵</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printGraph</span><span class="params">(Graph* graph)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;V; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; graph-&gt;V; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, graph-&gt;adjMatrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS 广度优先搜索</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(Graph* graph, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">    <span class="type">int</span> visited[MAX_VERTICES] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 标记访问的节点</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">queue</span>[MAX_VERTICES];  <span class="comment">// 队列</span></span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问起始节点</span></span><br><span class="line">    visited[start] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">queue</span>[rear++] = start;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nBFS starting from vertex %d: &quot;</span>, start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (front &lt; rear) &#123;</span><br><span class="line">        <span class="type">int</span> vertex = <span class="built_in">queue</span>[front++];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, vertex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问与当前节点相邻且未访问的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;V; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph-&gt;adjMatrix[vertex][i] == <span class="number">1</span> &amp;&amp; !visited[i]) &#123;</span><br><span class="line">                visited[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">queue</span>[rear++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS 深度优先搜索（使用递归）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSUtil</span><span class="params">(Graph* graph, <span class="type">int</span> vertex, <span class="type">int</span>* visited)</span> &#123;</span><br><span class="line">    <span class="comment">// 访问当前节点</span></span><br><span class="line">    visited[vertex] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, vertex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归访问所有与当前节点相邻的未访问节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;V; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph-&gt;adjMatrix[vertex][i] == <span class="number">1</span> &amp;&amp; !visited[i]) &#123;</span><br><span class="line">            DFSUtil(graph, i, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph* graph, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">    <span class="type">int</span> visited[MAX_VERTICES] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 标记访问的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nDFS starting from vertex %d: &quot;</span>, start);</span><br><span class="line">    DFSUtil(graph, start, visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个图并添加边</span></span><br><span class="line">    Graph* graph = createGraph(<span class="number">4</span>);  <span class="comment">// 4个顶点</span></span><br><span class="line">    addEdge(graph, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    addEdge(graph, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    addEdge(graph, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    addEdge(graph, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印图的邻接矩阵</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Graph&#x27;s Adjacency Matrix:\n&quot;</span>);</span><br><span class="line">    printGraph(graph);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行BFS和DFS</span></span><br><span class="line">    BFS(graph, <span class="number">0</span>);  <span class="comment">// 从节点0开始BFS</span></span><br><span class="line">    DFS(graph, <span class="number">0</span>);  <span class="comment">// 从节点0开始DFS</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放图的内存</span></span><br><span class="line">    <span class="built_in">free</span>(graph);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>深度优先搜索 (DFS)<br>DFS 是一种“深度”优先的遍历方式，意味着它会尽可能深地访问一个节点的子节点，直到无法继续深度访问为止，然后回溯并访问其他未被访问的节点。</li>
</ol>
<p>工作原理：<br>从一个起始节点开始，访问这个节点。<br>然后递归地访问所有与当前节点相邻且未被访问的节点，直到达到没有未访问的相邻节点为止。<br>当无法继续深度访问时，回到上一个节点，继续访问它的其他邻居。<br>特点：<br>递归或栈：DFS 通常使用递归或者显式栈来实现，依靠栈的后进先出（LIFO）特性来实现回溯。<br>深入探索：优先沿着一条路径探索下去，直到遇到死胡同，再回溯。<br>应用：用于求解连通分量、拓扑排序、寻找路径等问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">0</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">2</span></span><br><span class="line">|   |</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>0 -&gt; 1 -&gt; 3 -&gt; 2 -&gt; 4</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span> graph[][<span class="number">5</span>], <span class="type">int</span> node, <span class="type">int</span> visited[])</span> &#123;</span><br><span class="line">    visited[node] = <span class="number">1</span>;  <span class="comment">// 标记节点为已访问</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node);  <span class="comment">// 访问节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归访问与当前节点相邻的未访问节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph[node][i] == <span class="number">1</span> &amp;&amp; !visited[i]) &#123;</span><br><span class="line">            DFS(graph, i, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>BFS 是一种“宽度”优先的遍历方式，意味着它会先访问所有与起始节点直接相邻的节点，然后逐层扩展，访问与当前节点相邻的节点。</li>
</ol>
<p>工作原理：<br>从一个起始节点开始，访问这个节点。<br>然后访问所有与当前节点直接相邻的未访问节点，并将它们加入队列。<br>接着从队列中依次取出节点，继续访问它们的相邻节点，直到所有节点都被访问过。<br>特点：<br>队列：BFS 使用队列来实现，依靠队列的先进先出（FIFO）特性来保证按层次遍历。<br>层次遍历：优先访问与当前节点在同一层的节点，然后再向下访问下一层节点。<br>应用：用于最短路径查找、图的层次遍历、连通性等问题。<br>同样的例子</p>
<blockquote>
<p>0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4<br>看了代码就理解了</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(<span class="type">int</span> graph[][<span class="number">5</span>], <span class="type">int</span> start, <span class="type">int</span> visited[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">queue</span>[<span class="number">5</span>], front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    visited[start] = <span class="number">1</span>;  <span class="comment">// 标记起始节点为已访问</span></span><br><span class="line">    <span class="built_in">queue</span>[rear++] = start;  <span class="comment">// 将起始节点加入队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (front &lt; rear) &#123;</span><br><span class="line">        <span class="type">int</span> node = <span class="built_in">queue</span>[front++];  <span class="comment">// 从队列取出一个节点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node);  <span class="comment">// 访问节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问与当前节点相邻且未访问的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[node][i] == <span class="number">1</span> &amp;&amp; !visited[i]) &#123;</span><br><span class="line">                visited[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">queue</span>[rear++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图的连通性问题，最小生成树"><a href="#图的连通性问题，最小生成树" class="headerlink" title="图的连通性问题，最小生成树"></a>图的连通性问题，最小生成树</h2><p>Prim算法(基于贪心去实现的)<br>Kruskal算法(基于并查集去实现的)</p>
<ol>
<li>prim<br>它的基本思想是从图中的某个起始节点出发，逐步选择最小的边，扩展生成树，直到所有节点都被包含在内。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTICES 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF INT_MAX  <span class="comment">// 表示没有连接的边</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择最小的权重边</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">minKey</span><span class="params">(<span class="type">int</span> key[], <span class="type">int</span> mstSet[], <span class="type">int</span> vertices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> min = INF, min_index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; vertices; v++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mstSet[v] == <span class="number">0</span> &amp;&amp; key[v] &lt; min) &#123;</span><br><span class="line">            min = key[v];</span><br><span class="line">            min_index = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min_index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prim算法实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">prim</span><span class="params">(<span class="type">int</span> graph[MAX_VERTICES][MAX_VERTICES], <span class="type">int</span> vertices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> parent[MAX_VERTICES];  <span class="comment">// 存储生成树的父节点</span></span><br><span class="line">    <span class="type">int</span> key[MAX_VERTICES];     <span class="comment">// 存储权重值，key[i]表示从生成树到i的最小边权重</span></span><br><span class="line">    <span class="type">int</span> mstSet[MAX_VERTICES];  <span class="comment">// mstSet[i]为1表示顶点i已经包含在生成树中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertices; i++) &#123;</span><br><span class="line">        key[i] = INF;</span><br><span class="line">        mstSet[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    key[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// 从第一个顶点开始</span></span><br><span class="line">    parent[<span class="number">0</span>] = <span class="number">-1</span>;  <span class="comment">// 第一个顶点没有父节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成树包含所有顶点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> count = <span class="number">0</span>; count &lt; vertices - <span class="number">1</span>; count++) &#123;</span><br><span class="line">        <span class="comment">// 选择一个权重最小的顶点</span></span><br><span class="line">        <span class="type">int</span> u = minKey(key, mstSet, vertices);</span><br><span class="line">        </span><br><span class="line">        mstSet[u] = <span class="number">1</span>;  <span class="comment">// 将选择的顶点加入生成树</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新邻接顶点的key值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; vertices; v++) &#123;</span><br><span class="line">            <span class="comment">// graph[u][v]是从u到v的边的权重</span></span><br><span class="line">            <span class="keyword">if</span> (graph[u][v] &amp;&amp; mstSet[v] == <span class="number">0</span> &amp;&amp; graph[u][v] &lt; key[v]) &#123;</span><br><span class="line">                parent[v] = u;</span><br><span class="line">                key[v] = graph[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最小生成树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Edge \tWeight\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vertices; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d - %d \t%d\n&quot;</span>, parent[i], i, graph[i][parent[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> graph[MAX_VERTICES][MAX_VERTICES] = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> vertices = <span class="number">6</span>;  <span class="comment">// 图中顶点的数量</span></span><br><span class="line">    prim(graph, vertices);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Edge    Weight<br>0 - 1    2<br>1 - 2    3<br>0 - 3    6<br>3 - 4    5<br>4 - 5    3</li>
<li>Kruskal算法<br>Kruskal算法的步骤：</li>
<li>排序边：将图中的所有边按照权重从小到大进行排序。</li>
<li>初始化：每个顶点开始时是一个独立的集合，表示每个顶点都在自己的连通分量中。</li>
<li>遍历边：依次检查排序后的每一条边，如果边的两个端点属于不同的连通分量，就将它们连接起来，并合并这两个连通分量。</li>
<li>重复：直到生成树包含图中所有的顶点或者所有边都被处理完。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTICES 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 99999  <span class="comment">// 表示无穷大</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 边的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> u, v, weight;</span><br><span class="line">&#125; Edge;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较函数，用于排序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compareEdges</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((Edge *)a)-&gt;weight - ((Edge *)b)-&gt;weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找操作：返回顶点的父节点（即该顶点所在的连通分量）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findParent</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kruskal算法实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kruskal</span><span class="params">(<span class="type">int</span> graph[MAX_VERTICES][MAX_VERTICES], <span class="type">int</span> vertices)</span> &#123;</span><br><span class="line">    Edge edges[MAX_VERTICES * (MAX_VERTICES - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> edgeCount = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化边集合</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertices; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; vertices; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[i][j] != <span class="number">0</span> &amp;&amp; graph[i][j] != INF) &#123;</span><br><span class="line">                edges[edgeCount].u = i;</span><br><span class="line">                edges[edgeCount].v = j;</span><br><span class="line">                edges[edgeCount].weight = graph[i][j];</span><br><span class="line">                edgeCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照边的权重升序排序</span></span><br><span class="line">    qsort(edges, edgeCount, <span class="keyword">sizeof</span>(Edge), compareEdges);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> parent[MAX_VERTICES];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertices; i++) &#123;</span><br><span class="line">        parent[i] = i;  <span class="comment">// 每个顶点初始化为自己的父节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mstWeight = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Edge \tWeight\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历排序后的边集合</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edgeCount; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u = edges[i].u;</span><br><span class="line">        <span class="type">int</span> v = edges[i].v;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找u和v的父节点（连通分量）</span></span><br><span class="line">        <span class="type">int</span> rootU = findParent(parent, u);</span><br><span class="line">        <span class="type">int</span> rootV = findParent(parent, v);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果u和v的父节点不同，则说明它们不在同一个连通分量，加入生成树</span></span><br><span class="line">        <span class="keyword">if</span> (rootU != rootV) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d - %d \t%d\n&quot;</span>, u, v, edges[i].weight);</span><br><span class="line">            mstWeight += edges[i].weight;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 合并u和v的连通分量</span></span><br><span class="line">            parent[rootU] = rootV;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Minimum spanning tree weight: %d\n&quot;</span>, mstWeight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> graph[MAX_VERTICES][MAX_VERTICES] = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> vertices = <span class="number">6</span>;  <span class="comment">// 图中顶点的数量</span></span><br><span class="line">    kruskal(graph, vertices);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><p>问题抽象:在有向网中A点（源点）到达B点(终点)的多条路径中，寻找一条各边权值之和最小的路径，即最短路径。</p>
<h3 id="单源最短路-dijstra"><a href="#单源最短路-dijstra" class="headerlink" title="单源最短路 dijstra"></a>单源最短路 dijstra</h3><p>Dijkstra算法的步骤：<br>初始化：<br>将起点的最短路径初始化为0，其他所有节点的最短路径初始化为无穷大（表示尚未确定最短路径）<br>使用一个布尔数组（或集合）S，记录已经找到最短路径的节点<br>选择当前最短的节点：<br>在未被加入集合S的节点中，选择当前最短路径值最小的节点u<br>更新邻接节点的最短路径：<br>对于节点u的每个邻接节点v，如果通过u到v的路径更短，就更新v的最短路径<br>重复步骤2和3，直到所有节点的最短路径都被找到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTICES 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF INT_MAX  <span class="comment">// 表示无穷大</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择当前最短路径的节点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(<span class="type">int</span> dist[], <span class="type">int</span> sptSet[], <span class="type">int</span> vertices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> min = INF, min_index;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; vertices; v++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sptSet[v] == <span class="number">0</span> &amp;&amp; dist[v] &lt; min) &#123;</span><br><span class="line">            min = dist[v];</span><br><span class="line">            min_index = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> min_index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dijkstra算法实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dijkstra</span><span class="params">(<span class="type">int</span> graph[MAX_VERTICES][MAX_VERTICES], <span class="type">int</span> vertices, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">    <span class="type">int</span> dist[MAX_VERTICES];    <span class="comment">// 存储最短路径的数组</span></span><br><span class="line">    <span class="type">int</span> sptSet[MAX_VERTICES];  <span class="comment">// sptSet[i]表示顶点i是否在最短路径树中</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化dist数组和sptSet数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertices; i++) &#123;</span><br><span class="line">        dist[i] = INF;         <span class="comment">// 初始时所有点的最短路径设为无穷大</span></span><br><span class="line">        sptSet[i] = <span class="number">0</span>;         <span class="comment">// 所有顶点都不在最短路径树中</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dist[start] = <span class="number">0</span>;  <span class="comment">// 起点的最短路径为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算从起点到所有其他顶点的最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> count = <span class="number">0</span>; count &lt; vertices - <span class="number">1</span>; count++) &#123;</span><br><span class="line">        <span class="comment">// 选择最短路径的顶点</span></span><br><span class="line">        <span class="type">int</span> u = minDistance(dist, sptSet, vertices);</span><br><span class="line">        </span><br><span class="line">        sptSet[u] = <span class="number">1</span>;  <span class="comment">// 将u加入最短路径树</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新邻接节点的最短路径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; vertices; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[u][v] != <span class="number">0</span> &amp;&amp; sptSet[v] == <span class="number">0</span> &amp;&amp; dist[u] != INF &amp;&amp; dist[u] + graph[u][v] &lt; dist[v]) &#123;</span><br><span class="line">                dist[v] = dist[u] + graph[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Vertex\tDistance from Source\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertices; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d \t%d\n&quot;</span>, i, dist[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> graph[MAX_VERTICES][MAX_VERTICES] = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">10</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">9</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> vertices = <span class="number">6</span>;  <span class="comment">// 图中顶点的数量</span></span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;     <span class="comment">// 从顶点0开始计算最短路径</span></span><br><span class="line">    dijkstra(graph, vertices, start);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多源最短路-floyd"><a href="#多源最短路-floyd" class="headerlink" title="多源最短路 floyd"></a>多源最短路 floyd</h3><p>当然也可以跑n遍dijstra<br>floyd其实就是简单的动态规划</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTICES 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF INT_MAX  <span class="comment">// 无穷大，表示不可达</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Floyd-Warshall算法实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">floydWarshall</span><span class="params">(<span class="type">int</span> graph[MAX_VERTICES][MAX_VERTICES], <span class="type">int</span> vertices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> dist[MAX_VERTICES][MAX_VERTICES];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化dist数组为图的邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertices; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; vertices; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                dist[i][j] = <span class="number">0</span>;  <span class="comment">// 从顶点到自己，最短路径为0</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (graph[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                dist[i][j] = INF;  <span class="comment">// 如果没有边，设为无穷大</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dist[i][j] = graph[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态规划更新最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; vertices; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertices; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; vertices; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[i][k] != INF &amp;&amp; dist[k][j] != INF &amp;&amp; dist[i][j] &gt; dist[i][k] + dist[k][j]) &#123;</span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最终的最短路径矩阵</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shortest distances between every pair of vertices:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertices; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; vertices; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[i][j] == INF) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;INF\t&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, dist[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> graph[MAX_VERTICES][MAX_VERTICES] = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">3</span>, INF, INF, INF, INF&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, INF, INF, INF&#125;,</span><br><span class="line">        &#123;INF, <span class="number">1</span>, <span class="number">0</span>, <span class="number">7</span>, INF, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;INF, INF, <span class="number">7</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;INF, INF, INF, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;INF, INF, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> vertices = <span class="number">6</span>;  <span class="comment">// 图中的顶点数</span></span><br><span class="line">    floydWarshall(graph, vertices);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>思想：<br>计算每个顶点的入度。<br>将所有入度为0的顶点加入队列（或集合），它们没有任何依赖关系。<br>每次从队列中取出一个顶点，将其加入拓扑排序中，并将其邻接点的入度减1。如果某个邻接点的入度变为0，加入队列。<br>重复步骤3，直到所有顶点都被处理。如果图中存在环，说明无法进行拓扑排序。</p>
<p>步骤：<br>初始化一个队列，将所有入度为0的节点放入队列。<br>当队列不为空时：<br>从队列中取出一个节点。<br>将这个节点加入拓扑排序结果中。<br>遍历该节点的所有邻接节点，减少它们的入度。如果某个邻接节点的入度变为0，将其加入队列。<br>如果最终拓扑排序的节点数小于图中的总节点数，说明图中存在环，无法进行拓扑排序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTICES 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用邻接表表示图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> vertices;</span><br><span class="line">    <span class="type">int</span> adj[MAX_VERTICES][MAX_VERTICES];</span><br><span class="line">&#125; Graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化图</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initGraph</span><span class="params">(Graph *g, <span class="type">int</span> vertices)</span> &#123;</span><br><span class="line">    g-&gt;vertices = vertices;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertices; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; vertices; j++) &#123;</span><br><span class="line">            g-&gt;adj[i][j] = <span class="number">0</span>;  <span class="comment">// 初始化邻接矩阵</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加有向边</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addEdge</span><span class="params">(Graph *g, <span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    g-&gt;adj[u][v] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kahn算法实现拓扑排序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">topologicalSort</span><span class="params">(Graph *g)</span> &#123;</span><br><span class="line">    <span class="type">int</span> inDegree[MAX_VERTICES] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 入度数组</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">queue</span>[MAX_VERTICES], front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> result[MAX_VERTICES];</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算每个节点的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g-&gt;vertices; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g-&gt;vertices; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g-&gt;adj[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                inDegree[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有入度为0的节点加入队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g-&gt;vertices; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">queue</span>[rear++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理队列中的节点</span></span><br><span class="line">    <span class="keyword">while</span> (front &lt; rear) &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">queue</span>[front++];</span><br><span class="line">        result[idx++] = u;  <span class="comment">// 将节点加入拓扑排序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 减少邻接节点的入度，如果某个邻接节点的入度为0，则加入队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; g-&gt;vertices; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g-&gt;adj[u][v] == <span class="number">1</span>) &#123;</span><br><span class="line">                inDegree[v]--;</span><br><span class="line">                <span class="keyword">if</span> (inDegree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">queue</span>[rear++] = v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果拓扑排序的节点数等于图中的节点数，说明没有环，排序成功</span></span><br><span class="line">    <span class="keyword">if</span> (idx != g-&gt;vertices) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;图中有环，无法进行拓扑排序。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 返回0表示图中有环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出拓扑排序结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;拓扑排序结果：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g-&gt;vertices; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, result[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 返回1表示拓扑排序成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Graph g;</span><br><span class="line">    initGraph(&amp;g, <span class="number">6</span>);  <span class="comment">// 创建一个有6个顶点的图</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加边</span></span><br><span class="line">    addEdge(&amp;g, <span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">    addEdge(&amp;g, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">    addEdge(&amp;g, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">    addEdge(&amp;g, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">    addEdge(&amp;g, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    addEdge(&amp;g, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行拓扑排序</span></span><br><span class="line">    topologicalSort(&amp;g);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">5</span>      <span class="number">4</span></span><br><span class="line"> / \    / \</span><br><span class="line"><span class="number">2</span>   <span class="number">0</span>  <span class="number">0</span>   <span class="number">1</span></span><br><span class="line">    \    /</span><br><span class="line">     <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>拓扑排序结果：5 4 2 3 0 1</p>
</blockquote>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><ol>
<li>顺序查找（线性查找）<blockquote>
<p>for循环啊</p>
</blockquote>
</li>
<li>折半查找（二分查找）<br>初始范围：设定查找区间的左右边界，初始时为数组的开始和结束索引。<br>中间值：每次通过计算区间的中间元素（mid &#x3D; (low + high) &#x2F; 2），与目标值进行比较。<br>缩小范围：<br>如果中间值等于目标值，则查找成功。<br>如果目标值小于中间值，则将查找区间缩小为左半部分。<br>如果目标值大于中间值，则将查找区间缩小为右半部分。<br>继续查找：重复上述步骤，直到找到目标值或查找范围为空</li>
</ol>
<p>一定要保证是升序或者降序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> high = size - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="type">int</span> mid = low + (high - low) / <span class="number">2</span>;  <span class="comment">// 避免溢出</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;  <span class="comment">// 找到目标值，返回其索引</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;  <span class="comment">// 目标值在右侧，缩小范围到右半部分</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;  <span class="comment">// 目标值在左侧，缩小范围到左半部分</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 目标值不存在，返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>&#125;;</span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> target = <span class="number">7</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> result = binarySearch(arr, size, target);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;目标元素 %d 在数组中的位置是 %d\n&quot;</span>, target, result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;目标元素 %d 不在数组中\n&quot;</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>分块查找（索引顺序查找）<br>基本思路：<br>– （1）先让数据分块有序，即分成若干子表，<br>要求每个子表中的数据元素值都比后一块<br>中的数值小（但子表内部未必有序）</li>
</ol>
<ul>
<li>（2）然后将各子表中的最大关键字构成<br>一个索引表，表中还要包含每个子表的起<br>始地址。<br>分块 + 二分可以优化<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用二分查找在块内查找目标值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="type">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;  <span class="comment">// 找到目标值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;  <span class="comment">// 目标值在右侧</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;  <span class="comment">// 目标值在左侧</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 目标值不在块内</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分块查找</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">blockSearch</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> blockSize = (<span class="type">int</span>)<span class="built_in">sqrt</span>(size);  <span class="comment">// 块的大小为 sqrt(n)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找目标值所在的块</span></span><br><span class="line">    <span class="type">int</span> blockStart = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (blockStart &lt; size &amp;&amp; arr[blockStart + blockSize - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">        blockStart += blockSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在找到的块内进行二分查找</span></span><br><span class="line">    <span class="keyword">return</span> binarySearch(arr, blockStart, blockStart + blockSize - <span class="number">1</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">25</span>, <span class="number">27</span>&#125;;</span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> target = <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = blockSearch(arr, size, target);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;目标元素 %d 在数组中的位置是 %d\n&quot;</span>, target, result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;目标元素 %d 不在数组中\n&quot;</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><p>二叉排序树的基本操作：</p>
<ol>
<li>查找（Search）：根据树的性质，从根节点开始，比较目标值与当前节点的值：</li>
</ol>
<p>如果目标值小于当前节点的值，则在左子树中查找。<br>如果目标值大于当前节点的值，则在右子树中查找。<br>如果目标值等于当前节点的值，则查找成功，返回该节点。<br>2. 插入（Insert）：从根节点开始，逐层比较待插入值与当前节点的值，找到合适的位置后插入新的节点。</p>
<ol start="3">
<li>删除（Delete）：删除节点有三种情况：</li>
</ol>
<p>删除的节点没有子节点：直接删除该节点。<br>删除的节点有一个子节点：用该节点的唯一子节点代替该节点。<br>删除的节点有两个子节点：找到该节点的右子树中的最小节点（即中序遍历的下一个节点），用该最小节点的值替代当前节点的值，再删除该最小节点。<br>4. 遍历（Traversal）：常用的遍历方法有：</p>
<p>前序遍历（Pre-order Traversal）：根节点 -&gt; 左子树 -&gt; 右子树。<br>中序遍历（In-order Traversal）：左子树 -&gt; 根节点 -&gt; 右子树。<br>后序遍历（Post-order Traversal）：左子树 -&gt; 右子树 -&gt; 根节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新节点</span></span><br><span class="line">Node* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* newNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;left = newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入节点</span></span><br><span class="line">Node* <span class="title function_">insert</span><span class="params">(Node* root, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> createNode(data); <span class="comment">//注意没有return，所以可以这么写</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (data &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;left = insert(root-&gt;left, data);  <span class="comment">// 插入左子树</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root-&gt;right = insert(root-&gt;right, data);  <span class="comment">// 插入右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找节点</span></span><br><span class="line">Node* <span class="title function_">search</span><span class="params">(Node* root, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;data == data) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (data &lt; root-&gt;data) &#123;</span><br><span class="line">        <span class="keyword">return</span> search(root-&gt;left, data);  <span class="comment">// 在左子树查找</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> search(root-&gt;right, data);  <span class="comment">// 在右子树查找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line">Node* <span class="title function_">deleteNode</span><span class="params">(Node* root, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找要删除的节点</span></span><br><span class="line">    <span class="keyword">if</span> (data &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, data);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到节点</span></span><br><span class="line">        <span class="comment">// 1. 删除的节点没有子节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            root = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 删除的节点只有一个子节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Node* temp = root;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Node* temp = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 删除的节点有两个子节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node* temp = root-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (temp &amp;&amp; temp-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                temp = temp-&gt;left;  <span class="comment">// 找到右子树的最小节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            root-&gt;data = temp-&gt;data;  <span class="comment">// 用右子树最小节点的值替代当前节点</span></span><br><span class="line">            root-&gt;right = deleteNode(root-&gt;right, temp-&gt;data);  <span class="comment">// 删除右子树最小节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorderTraversal</span><span class="params">(Node* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorderTraversal(root-&gt;left);  <span class="comment">// 访问左子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);     <span class="comment">// 访问根节点</span></span><br><span class="line">    inorderTraversal(root-&gt;right); <span class="comment">// 访问右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Node* root = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    root = insert(root, <span class="number">50</span>);</span><br><span class="line">    root = insert(root, <span class="number">30</span>);</span><br><span class="line">    root = insert(root, <span class="number">20</span>);</span><br><span class="line">    root = insert(root, <span class="number">40</span>);</span><br><span class="line">    root = insert(root, <span class="number">70</span>);</span><br><span class="line">    root = insert(root, <span class="number">60</span>);</span><br><span class="line">    root = insert(root, <span class="number">80</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中序遍历：输出顺序应该是升序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;中序遍历结果：&quot;</span>);</span><br><span class="line">    inorderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    Node* result = search(root, <span class="number">40</span>);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了节点 %d\n&quot;</span>, result-&gt;data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;节点未找到\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    root = deleteNode(root, <span class="number">20</span>);</span><br><span class="line">    root = deleteNode(root, <span class="number">30</span>);</span><br><span class="line">    root = deleteNode(root, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历：删除后的结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除后中序遍历结果：&quot;</span>);</span><br><span class="line">    inorderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题是可能退化成链，所以这里需要引入平衡树的概念<br>课本中学的是AVL树<br>就四个操作<br>右旋</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    y                                  x</span><br><span class="line">   / \                               /   \</span><br><span class="line">  x   T4     Right <span class="title function_">Rotate</span><span class="params">(y)</span>      z       y</span><br><span class="line"> / \       - - - - - - - - - - - &gt; / \     / \</span><br><span class="line">z   T3                            T1   T2   T3  T4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>左旋</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  x                                y</span><br><span class="line"> /  \                             /   \</span><br><span class="line">T1    y     Left <span class="title function_">Rotate</span><span class="params">(x)</span>     x       z</span><br><span class="line">    /  \   - - - - - - - - - - &gt; /  \    /  \</span><br><span class="line">   T2   z                       T1   T2  T3   T4</span><br></pre></td></tr></table></figure>
<p>左-右旋</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    z                            x                           z</span><br><span class="line">   / \                         /   \                       /   \</span><br><span class="line">  x   T4   Left <span class="title function_">Rotate</span><span class="params">(z)</span>    y      T4  Right <span class="title function_">Rotate</span><span class="params">(x)</span>  x       y</span><br><span class="line"> / \      - - - - - - - - - - &gt; / \                        / \     / \</span><br><span class="line">T1   y                        T1   x                      T1   T2   T3  T4</span><br><span class="line">     / \                      /  \ </span><br><span class="line">    T2   T3                  T2   T3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>右-左旋</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  x                           z                            x</span><br><span class="line"> / \                         /   \                        /   \</span><br><span class="line">T1   z   Right <span class="title function_">Rotate</span><span class="params">(x)</span>   y      T2   Left <span class="title function_">Rotate</span><span class="params">(z)</span>  y       z</span><br><span class="line">    / \   - - - - - - - - - &gt; / \                       / \     / \</span><br><span class="line">   y   T3                    T1   x                     T1   T2  T3  T4</span><br><span class="line">  / \                          /  \ </span><br><span class="line"> T2   T3                      T3   T4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>贴个代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">right</span>;</span></span><br><span class="line">    <span class="type">int</span> height;  <span class="comment">// 记录树的高度</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取节点的高度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">height</span><span class="params">(Node* node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取节点的平衡因子</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getBalanceFactor</span><span class="params">(Node* node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> height(node-&gt;left) - height(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新节点</span></span><br><span class="line">Node* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* newNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;left = newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;height = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右旋操作</span></span><br><span class="line">Node* <span class="title function_">rightRotate</span><span class="params">(Node* y)</span> &#123;</span><br><span class="line">    Node* x = y-&gt;left;</span><br><span class="line">    Node* T2 = x-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旋转</span></span><br><span class="line">    x-&gt;right = y;</span><br><span class="line">    y-&gt;left = T2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新高度</span></span><br><span class="line">    y-&gt;height = <span class="number">1</span> + (height(y-&gt;left) &gt; height(y-&gt;right) ? height(y-&gt;left) : height(y-&gt;right));</span><br><span class="line">    x-&gt;height = <span class="number">1</span> + (height(x-&gt;left) &gt; height(x-&gt;right) ? height(x-&gt;left) : height(x-&gt;right));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左旋操作</span></span><br><span class="line">Node* <span class="title function_">leftRotate</span><span class="params">(Node* x)</span> &#123;</span><br><span class="line">    Node* y = x-&gt;right;</span><br><span class="line">    Node* T2 = y-&gt;left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旋转</span></span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">    x-&gt;right = T2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新高度</span></span><br><span class="line">    x-&gt;height = <span class="number">1</span> + (height(x-&gt;left) &gt; height(x-&gt;right) ? height(x-&gt;left) : height(x-&gt;right));</span><br><span class="line">    y-&gt;height = <span class="number">1</span> + (height(y-&gt;left) &gt; height(y-&gt;right) ? height(y-&gt;left) : height(y-&gt;right));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入操作</span></span><br><span class="line">Node* <span class="title function_">insert</span><span class="params">(Node* node, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 插入普通的二叉搜索树</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> createNode(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data &lt; node-&gt;data) &#123;</span><br><span class="line">        node-&gt;left = insert(node-&gt;left, data);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; node-&gt;data) &#123;</span><br><span class="line">        node-&gt;right = insert(node-&gt;right, data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node;  <span class="comment">// 不允许插入重复的元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 更新当前节点的高度</span></span><br><span class="line">    node-&gt;height = <span class="number">1</span> + (height(node-&gt;left) &gt; height(node-&gt;right) ? height(node-&gt;left) : height(node-&gt;right));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 检查是否需要旋转</span></span><br><span class="line">    <span class="type">int</span> balance = getBalanceFactor(node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左左情况（右旋）</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; data &lt; node-&gt;left-&gt;data) &#123;</span><br><span class="line">        <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右右情况（左旋）</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; data &gt; node-&gt;right-&gt;data) &#123;</span><br><span class="line">        <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右情况（左旋再右旋）</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; data &gt; node-&gt;left-&gt;data) &#123;</span><br><span class="line">        node-&gt;left = leftRotate(node-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右左情况（右</span></span><br></pre></td></tr></table></figure>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>重点是哈希冲突，简单来讲就是1 % 13 &#x3D;&#x3D; 14 % 13， 两个数具有相同的哈希值</p>
<p>优化：</p>
<p>选择合适的质数：使用质数作为哈希表的大小可以显著减少冲突。如果选择的质数太小，可能会导致哈希表容量不足；如果太大，则可能浪费空间。</p>
<p>变种哈希函数：为了进一步减少冲突，可以使用更多的哈希函数组合，或使用一些其他哈希技术，如 乘法散列法、位运算、多项式哈希法 等<br>会除留余数法就好了</p>
<p>有冲突时就去寻找下一个空的哈希地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TABLE_SIZE 11  <span class="comment">// 选择一个质数作为哈希表大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *table;  <span class="comment">// 哈希表</span></span><br><span class="line">    <span class="type">int</span> size;    <span class="comment">// 哈希表大小</span></span><br><span class="line">&#125; HashTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建哈希表</span></span><br><span class="line">HashTable* <span class="title function_">createTable</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">    HashTable* hashTable = (HashTable*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashTable));</span><br><span class="line">    hashTable-&gt;size = size;</span><br><span class="line">    hashTable-&gt;table = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化哈希表，所有位置设置为 -1，表示空</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        hashTable-&gt;table[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> hashTable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希函数：除留余数法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> key % size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(HashTable* hashTable, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = hash(key, hashTable-&gt;size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理冲突，使用开放寻址法（线性探测）</span></span><br><span class="line">    <span class="keyword">while</span> (hashTable-&gt;table[index] != <span class="number">-1</span>) &#123;</span><br><span class="line">        index = (index + <span class="number">1</span>) % hashTable-&gt;size;  <span class="comment">// 线性探测</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    hashTable-&gt;table[index] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(HashTable* hashTable, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = hash(key, hashTable-&gt;size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="keyword">while</span> (hashTable-&gt;table[index] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashTable-&gt;table[index] == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 找到元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        index = (index + <span class="number">1</span>) % hashTable-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 未找到元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印哈希表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printTable</span><span class="params">(HashTable* hashTable)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; hashTable-&gt;size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashTable-&gt;table[i] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, hashTable-&gt;table[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;X &quot;</span>);  <span class="comment">// X 表示空位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    HashTable* hashTable = createTable(TABLE_SIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入数据</span></span><br><span class="line">    insert(hashTable, <span class="number">23</span>);</span><br><span class="line">    insert(hashTable, <span class="number">45</span>);</span><br><span class="line">    insert(hashTable, <span class="number">67</span>);</span><br><span class="line">    insert(hashTable, <span class="number">12</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印哈希表</span></span><br><span class="line">    printTable(hashTable);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search 45: %d\n&quot;</span>, search(hashTable, <span class="number">45</span>));  <span class="comment">// 找到</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Search 100: %d\n&quot;</span>, search(hashTable, <span class="number">100</span>));  <span class="comment">// 未找到</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>排序的定义不需要介绍了吧<br>有几个比较简单的直接看代码就好了</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>每步将一个待排序的对象，按其关键码大小，插入到前面已经排好序的一组对象的适当位置上，直到对象全部插入为止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, key, j;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从第二个元素开始插入排序</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        key = arr[i];  <span class="comment">// 当前要插入的元素</span></span><br><span class="line">        j = i - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将大于 key 的元素向右移动</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将 key 插入到合适的位置</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化：二分插入排序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找，返回插入位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到插入位置</span></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid + <span class="number">1</span>; <span class="comment">// 返回插入位置（在相同元素后面插入）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; key) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left; <span class="comment">// 返回插入位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分插入排序函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">binaryInsertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, key, j, insertPos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        key = arr[i];  <span class="comment">// 当前要插入的元素</span></span><br><span class="line">        insertPos = binarySearch(arr, <span class="number">0</span>, i - <span class="number">1</span>, key); <span class="comment">// 找到插入位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将大于 key 的元素向右移动</span></span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= insertPos; j--) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 插入 key 到正确位置</span></span><br><span class="line">        arr[insertPos] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Original array: \n&quot;</span>);</span><br><span class="line">    printArray(arr, n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用二分插入排序</span></span><br><span class="line">    binaryInsertionSort(arr, n);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sorted array: \n&quot;</span>);</span><br><span class="line">    printArray(arr, n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过只是优化了常数，因为本身的交换缺陷，无法更快</p>
<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><p>两两比较，如果发生逆序则交换，直到所有记录都排好序为止</p>
<h3 id="起泡排序-Bubble-Sorting"><a href="#起泡排序-Bubble-Sorting" class="headerlink" title="起泡排序(Bubble Sorting)"></a>起泡排序(Bubble Sorting)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, temp;</span><br><span class="line">    <span class="type">int</span> swapped;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 外层循环控制遍历次数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        swapped = <span class="number">0</span>;  <span class="comment">// 标志位，记录当前遍历是否发生了交换</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 内层循环进行相邻元素比较和交换</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换元素</span></span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                </span><br><span class="line">                swapped = <span class="number">1</span>;  <span class="comment">// 发生了交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果这一轮没有交换，说明数组已经有序，可以提前退出</span></span><br><span class="line">        <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>【三分钟学会快速排序-哔哩哔哩】 <a target="_blank" rel="noopener" href="https://b23.tv/7IwWAC3">https://b23.tv/7IwWAC3</a><br>还行,很有必要学</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分区操作，返回基准元素的位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[high];  <span class="comment">// 选择最右边的元素作为基准</span></span><br><span class="line">    <span class="type">int</span> i = low - <span class="number">1</span>;  <span class="comment">// i指向比基准元素小的区域的末尾</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数组，找到比基准小的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = low; j &lt;= high - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">// 交换arr[i]和arr[j]</span></span><br><span class="line">            <span class="type">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将基准元素交换到正确的位置</span></span><br><span class="line">    <span class="type">int</span> temp = arr[i + <span class="number">1</span>];</span><br><span class="line">    arr[i + <span class="number">1</span>] = arr[high];</span><br><span class="line">    arr[high] = temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;  <span class="comment">// 返回基准元素的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// 获取基准元素的位置</span></span><br><span class="line">        <span class="type">int</span> pi = partition(arr, low, high);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对基准元素左侧和右侧的子数组递归排序</span></span><br><span class="line">        quickSort(arr, low, pi - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pi + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>首先通过n-1次关键字比较，从n个记录中找出关键字最小的记录，将它与第1个记录交换<br>2.再通过n-2次比较，从剩余的n-1个记录中找出关键字次小的记录，将它与第2个记录交换<br>3.重复上述操作，共进行n-1趟排序后，排序结束</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树形选择排序"><a href="#树形选择排序" class="headerlink" title="树形选择排序"></a>树形选择排序</h2><p>基本思想：首先对n个记录的关键字进行两两比较，然后在其中┎ n&#x2F;2 ┐个较小者之间再进行两两比较，如此重复，直至选出最小关键字的记录为止。<br>实现：这个过程可用一棵有n个叶子结点的完全二叉树表示树表示<br>建树是nlogn，每次选择是logn，所以总的是nlogn，常数项比较大</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个二叉树节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的节点</span></span><br><span class="line">Node* <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据到二叉树</span></span><br><span class="line">Node* <span class="title function_">insert</span><span class="params">(Node* root, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> newNode(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;left = insert(root-&gt;left, data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root-&gt;right = insert(root-&gt;right, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历输出树的数据（升序排列）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorderTraversal</span><span class="params">(Node* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        inorderTraversal(root-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);</span><br><span class="line">        inorderTraversal(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找树中的最小节点</span></span><br><span class="line">Node* <span class="title function_">findMin</span><span class="params">(Node* root)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (root &amp;&amp; root-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = root-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从树中删除最小节点</span></span><br><span class="line">Node* <span class="title function_">deleteMin</span><span class="params">(Node* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Node* rightChild = root-&gt;right;</span><br><span class="line">        <span class="built_in">free</span>(root);</span><br><span class="line">        <span class="keyword">return</span> rightChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root-&gt;left = deleteMin(root-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树形选择排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">treeSelectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    Node* root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有数组元素插入到树中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        root = insert(root, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从树中提取最小元素并放到数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Node* minNode = findMin(root);</span><br><span class="line">        arr[i] = minNode-&gt;data;</span><br><span class="line">        root = deleteMin(root);  <span class="comment">// 删除最小元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">64</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Original array: \n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    treeSelectionSort(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sorted array: \n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>分为大根堆和小根堆，就是字面意思<br>这里建议看一下课件，描述不如图片直观</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个数的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整堆（最大堆）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">int</span> largest = i;  <span class="comment">// 初始化最大元素为当前节点</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;  <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;  <span class="comment">// 右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子节点大于父节点</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果右子节点大于当前最大元素</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最大元素不是父节点，则交换并继续调整</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        swap(&amp;arr[i], &amp;arr[largest]);</span><br><span class="line">        heapify(arr, n, largest);  <span class="comment">// 递归调整</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序主函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 构建最大堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(arr, n, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从堆中一个个取出最大元素，并调整堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 交换当前根节点和最后一个元素</span></span><br><span class="line">        swap(&amp;arr[<span class="number">0</span>], &amp;arr[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整堆，排除掉已排序的元素</span></span><br><span class="line">        heapify(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Original array: \n&quot;</span>);</span><br><span class="line">    printArray(arr, n);</span><br><span class="line"></span><br><span class="line">    heapSort(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sorted array: \n&quot;</span>);</span><br><span class="line">    printArray(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>递归的将两个已经排序的序列合并成一个序列<br>还是建议看课件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个有序子数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算子数组的长度</span></span><br><span class="line">    <span class="type">int</span> n1 = mid - left + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n2 = right - mid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建临时数组</span></span><br><span class="line">    <span class="type">int</span> L[n1], R[n2];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝数据到临时数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">        L[i] = arr[left + i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n2; i++)</span><br><span class="line">        R[i] = arr[mid + <span class="number">1</span> + i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个临时数组</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L[i] &lt;= R[j]) &#123;</span><br><span class="line">            arr[k] = L[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k] = R[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子数组还有剩余</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">        arr[k] = L[i];</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果右子数组还有剩余</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">        arr[k] = R[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 找到中点</span></span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归对左右两部分进行归并排序</span></span><br><span class="line">        mergeSort(arr, left, mid);</span><br><span class="line">        mergeSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并两个已排序的部分</span></span><br><span class="line">        merge(arr, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Original array: \n&quot;</span>);</span><br><span class="line">    printArray(arr, n);</span><br><span class="line"></span><br><span class="line">    mergeSort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sorted array: \n&quot;</span>);</span><br><span class="line">    printArray(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="完结撒花，建议配合ppt使用"><a href="#完结撒花，建议配合ppt使用" class="headerlink" title="完结撒花，建议配合ppt使用"></a>完结撒花，建议配合ppt使用</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://yansmaoa.github.io">Ysmmm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://yansmaoa.github.io/2024/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A02/">https://yansmaoa.github.io/2024/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A02/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yansmaoa.github.io" target="_blank">Ysmmm的快乐小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">期末复习</a></div><div class="post_share"><div class="social-share" data-image="/img/v2-1cb481e27656b14e14b2878d6c47e544_r.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/11/28/JAVA-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/" title="JAVA-学习笔记2"><img class="cover" src="/img/v2-1cb481e27656b14e14b2878d6c47e544_r.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JAVA-学习笔记2</div></div></a></div><div class="next-post pull-right"><a href="/2024/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/" title="数据结构复习"><img class="cover" src="/img/v2-1cb481e27656b14e14b2878d6c47e544_r.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据结构复习</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/" title="数据结构复习"><img class="cover" src="/img/v2-1cb481e27656b14e14b2878d6c47e544_r.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-26</div><div class="title">数据结构复习</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/saierda.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Ysmmm</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/YANSMAoA"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=1850955441&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="https://github.com/YANSMAoA" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1850955441@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%B2-String"><span class="toc-number">1.</span> <span class="toc-text">串(String)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#string%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">string类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">KMP算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">数组和广义表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.</span> <span class="toc-text">树和二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">3.1.</span> <span class="toc-text">树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.2.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">3.2.1.</span> <span class="toc-text">哈夫曼编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%92%8C-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.2.2.</span> <span class="toc-text">满二叉树 和 完全二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%EF%BC%8C%E9%81%8D%E5%8E%86"><span class="toc-number">3.2.3.</span> <span class="toc-text">树的建立，遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.2.4.</span> <span class="toc-text">线索二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E4%B8%8E%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.2.5.</span> <span class="toc-text">森林与树与二叉树的转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">4.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%BB%BA%E5%9B%BE%EF%BC%8Cdfs-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-bfs-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">4.2.</span> <span class="toc-text">实现建图，dfs(深度优先遍历), bfs(广度优先遍历)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%8C%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">4.3.</span> <span class="toc-text">图的连通性问题，最小生成树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">4.4.</span> <span class="toc-text">最短路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF-dijstra"><span class="toc-number">4.4.1.</span> <span class="toc-text">单源最短路 dijstra</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF-floyd"><span class="toc-number">4.4.2.</span> <span class="toc-text">多源最短路 floyd</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">4.5.</span> <span class="toc-text">拓扑排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">5.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">5.1.</span> <span class="toc-text">线性表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="toc-number">5.2.</span> <span class="toc-text">二叉排序树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">5.3.</span> <span class="toc-text">哈希表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">6.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">6.1.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-number">6.2.</span> <span class="toc-text">交换排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%B7%E6%B3%A1%E6%8E%92%E5%BA%8F-Bubble-Sorting"><span class="toc-number">6.2.1.</span> <span class="toc-text">起泡排序(Bubble Sorting)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">6.2.2.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">6.2.3.</span> <span class="toc-text">选择排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%BD%A2%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">6.3.</span> <span class="toc-text">树形选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">6.4.</span> <span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">6.5.</span> <span class="toc-text">归并排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%8C%E7%BB%93%E6%92%92%E8%8A%B1%EF%BC%8C%E5%BB%BA%E8%AE%AE%E9%85%8D%E5%90%88ppt%E4%BD%BF%E7%94%A8"><span class="toc-number">7.</span> <span class="toc-text">完结撒花，建议配合ppt使用</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/JAVA-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/" title="JAVA-学习笔记2">JAVA-学习笔记2</a><time datetime="2024-11-28T02:42:17.000Z" title="发表于 2024-11-28 10:42:17">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A02/" title="数据结构复习2">数据结构复习2</a><time datetime="2024-11-26T16:49:55.000Z" title="发表于 2024-11-27 00:49:55">2024-11-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/" title="数据结构复习">数据结构复习</a><time datetime="2024-11-26T05:35:16.000Z" title="发表于 2024-11-26 13:35:16">2024-11-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/19/JAVA-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="JAVA 学习笔记">JAVA 学习笔记</a><time datetime="2024-11-19T03:29:35.000Z" title="发表于 2024-11-19 11:29:35">2024-11-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/07/%E4%B8%93%E9%A2%98%E5%A4%8D%E4%B9%A07-%E7%AE%97%E6%B3%95%E7%AD%96%E7%95%A5/" title="专题复习7-算法策略">专题复习7-算法策略</a><time datetime="2024-11-06T17:37:11.000Z" title="发表于 2024-11-07 01:37:11">2024-11-07</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/v2-1cb481e27656b14e14b2878d6c47e544_r.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Ysmmm</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>