<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>myserver-helloword | Ysmmm的快乐小屋</title><meta name="author" content="Ysmmm"><meta name="copyright" content="Ysmmm"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前置知识 - C++⾯向对象编程（OOP） 封装：通过public，private，protected 来实现类的访问权限。 继承：复⽤现有类功能的⽅式，通过派⽣新类来扩展原有类的功能，⽽⽆需重新编写原始代码。 多态：使⼀个类的不同实例在不同情况下表现出不同的⾏为特性，使得具有不同内部结构的 抽象：通过抽象类和接⼝定义对象的⾏为，忽略具体的实现细节。对象能够共享相同的外部接⼝，从⽽达到灵活和统⼀处">
<meta property="og:type" content="article">
<meta property="og:title" content="myserver-helloword">
<meta property="og:url" content="https://yansmaoa.github.io/2025/03/20/myserver-helloword/index.html">
<meta property="og:site_name" content="Ysmmm的快乐小屋">
<meta property="og:description" content="前置知识 - C++⾯向对象编程（OOP） 封装：通过public，private，protected 来实现类的访问权限。 继承：复⽤现有类功能的⽅式，通过派⽣新类来扩展原有类的功能，⽽⽆需重新编写原始代码。 多态：使⼀个类的不同实例在不同情况下表现出不同的⾏为特性，使得具有不同内部结构的 抽象：通过抽象类和接⼝定义对象的⾏为，忽略具体的实现细节。对象能够共享相同的外部接⼝，从⽽达到灵活和统⼀处">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yansmaoa.github.io/img/v2-1cb481e27656b14e14b2878d6c47e544_r.jpg">
<meta property="article:published_time" content="2025-03-20T13:41:03.000Z">
<meta property="article:modified_time" content="2025-03-24T03:19:59.487Z">
<meta property="article:author" content="Ysmmm">
<meta property="article:tag" content="server">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yansmaoa.github.io/img/v2-1cb481e27656b14e14b2878d6c47e544_r.jpg"><link rel="shortcut icon" href="/img/jinke.png"><link rel="canonical" href="https://yansmaoa.github.io/2025/03/20/myserver-helloword/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'myserver-helloword',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-24 11:19:59'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/saierda.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">57</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/v2-1cb481e27656b14e14b2878d6c47e544_r.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Ysmmm的快乐小屋"><span class="site-name">Ysmmm的快乐小屋</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">myserver-helloword</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-20T13:41:03.000Z" title="发表于 2025-03-20 21:41:03">2025-03-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-24T03:19:59.487Z" title="更新于 2025-03-24 11:19:59">2025-03-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="myserver-helloword"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前置知识-C"><a href="#前置知识-C" class="headerlink" title="前置知识 - C++"></a>前置知识 - C++</h1><h2 id="⾯向对象编程（OOP）"><a href="#⾯向对象编程（OOP）" class="headerlink" title="⾯向对象编程（OOP）"></a>⾯向对象编程（OOP）</h2><ol>
<li>封装：通过public，private，protected 来实现类的访问权限。</li>
<li>继承：复⽤现有类功能的⽅式，通过派⽣新类来扩展原有类的功能，⽽⽆需重新编写原始代码。</li>
<li>多态：使⼀个类的不同实例在不同情况下表现出不同的⾏为特性，使得具有不同内部结构的</li>
<li>抽象：通过抽象类和接⼝定义对象的⾏为，忽略具体的实现细节。<br>对象能够共享相同的外部接⼝，从⽽达到灵活和统⼀处理的⽬的。<ul>
<li>静态多态（编译时多态）：通过函数重载（Overloading）和模板技术（Templates）实现。</li>
<li>动态多态（运⾏时多态）：通过虚函数（Virtual Functions）和继承关系实现。</li>
</ul>
</li>
</ol>
<h2 id="静态全局变量（static）"><a href="#静态全局变量（static）" class="headerlink" title="静态全局变量（static）"></a>静态全局变量（static）</h2><ul>
<li>静态成员变量：可以通过类名直接访问，⽆需创建类的对象，从程序开始到结束。</li>
<li>静态成员函数：不与任何对象实例关联，通过类名直接调⽤，可访问静态数据成员，不能直接访问⾮静态数据成员（需通过对象引⽤或指针）。</li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><ul>
<li>纯虚函数：在基类中声明但没有提供实现的虚函数，必须在所有⾮抽象派⽣类中实现。纯虚函数使⽤&#x3D;0来标识。</li>
<li>虚函数的⼯作基于运⾏时类型信息（RTTI）和虚函数表（VTable）。每个具有虚函数的类都会有⼀个隐藏的虚函数表，其中包含了指向虚函数地址的指针数组。当创建⼀个对象时，编译器会在对象内部添加⼀个指向其对应类的虚函数表的指针（vptr）。当通过基类指针调⽤虚函数时，实际上是通过这个vptr找到正确的虚函数表，然后执⾏对应的函数。</li>
<li>虚函数表是针对类的。同⼀个类的所有对象共享同⼀个虚函数表。每个对象内部都保存⼀个指向该类虚函数表的指针 vptr 。虽然每个对象的 vptr 地址不同，但它们都指向同⼀个虚函数表。</li>
<li>构造函数不可以是虚函数。原因是虚函数的调⽤依赖于虚函数表，⽽虚函数表的指针 vptr 需要在对象的构造函数中初始化。在构造函数执⾏之前， vptr 还未被初始化，因此⽆法使⽤虚函数机制。</li>
<li>当使⽤基类指针指向派⽣类对象时，为了正确调⽤派⽣类的析构函数来释放资源，基类的析构函数需要定义为虚函数。如果析构函数不是虚函数，那么在删除派⽣类对象时，可能⽆法正确调⽤派⽣类的析构函数，导致资源泄漏。</li>
</ul>
<h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><ul>
<li>构造函数：从语法上讲，构造函数可以抛出异常。但从逻辑和⻛险控制的⻆度来说，应尽量避免在<br>构造函数中抛出异常。如果构造函数抛出异常，可能会导致资源（如已分配的内存）⽆法正确释<br>放，从⽽引起内存泄漏。</li>
<li>析构函数：析构函数不应该抛出异常。如果析构函数中抛出异常，可能会导致程序中断或⽆法正确<br>释放资源。特别是在异常处理过程中，如果另⼀个异常被抛出（⽽当前异常还未处理完毕），程序<br>可能会直接终⽌。因此，析构函数应该捕获并处理其内部可能产⽣的任何异常，⽽不是抛出它们。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>() &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 构造函数中的代码</span></span><br><span class="line">        &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">            <span class="comment">// 处理构造过程中的异常</span></span><br><span class="line">        <span class="keyword">throw</span>; <span class="comment">// 重新抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Example</span>() &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 析构函数中的代码</span></span><br><span class="line">       &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">           <span class="comment">// 处理析构过程中的异常</span></span><br><span class="line">            <span class="comment">// 不要重新抛出异常</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><ol>
<li>栈（Stack）：<ul>
<li>栈上存储的数据主要包括：局部变量（包括基本类型和内置数组等）、函数参数、返回地址以及编译器⾃动分配的临时变量。（简单说基本就是new之外的局部变量都在这⾥）</li>
<li>存储特点 :<ul>
<li>⾃动分配和释放：栈空间由编译器⾃动管理，当作⽤域结束时，栈上的变量会⾃动销毁，⽆需程序员⼿动释放。</li>
<li>空间有限且固定：栈的⼤⼩⼀般在程序启动时由系统预先设定，并且有限制。如果栈上分配的空间过⼤，可能导致栈溢出。</li>
<li>⽆碎⽚区分：栈上存储的数据连续，不会产⽣内存碎⽚。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> stackVariable = <span class="number">10</span>; <span class="comment">// 这个变量存储在栈上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>堆（Heap）：<ul>
<li>堆上存储的数据主要包括：通过 new 操作符动态分配的对象、数组或其他数据结构。</li>
<li>存储特点：<ul>
<li>动态分配和释放：使⽤ new 申请内存后，需要通过 delete 来释放，否则会导致内存泄漏；同样， malloc 与 free 配合使⽤也是相同道理。</li>
<li>⼤⼩灵活可变：堆内存空间可以根据需要动态调整，没有固定的上限，但受限于系统资源。</li>
<li>可能产⽣内存碎⽚：由于频繁地分配和释放不同⼤⼩的内存块，可能会导致堆内存中存在⽆法利⽤的⼩块内存，即内存碎⽚。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* heapVariable = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>); <span class="comment">// 这个对象存储在堆上</span></span><br><span class="line"><span class="keyword">delete</span> heapVariable;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="前置知识-STL"><a href="#前置知识-STL" class="headerlink" title="前置知识-STL"></a>前置知识-STL</h1><h2 id="编译时连接库"><a href="#编译时连接库" class="headerlink" title="编译时连接库"></a>编译时连接库</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -o main -l&lt;library_name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接的本质是将程序中的符号引⽤（如函数调⽤、变量访问等）与它们的定义关联起来。C++ 程序通<br>常分为多个源⽂件或模块，每个模块可能会调⽤其他模块中的函数或使⽤其他模块中的变量。链接过<br>程确保每个符号都有正确的定义和实现，并将它们整合成⼀个最终的可执⾏⽂件或动态库。</p>
<ul>
<li>静态链接：在编译时将库的代码嵌⼊到可执⾏⽂件中，⽣成的可执⾏⽂件不需要依赖外部的库⽂件。</li>
<li>动态链接：在运⾏时加载外部的库⽂件（如 .dll 或 .so ⽂件），可执⾏⽂件只包含库的引⽤，库的实际代码存储在外部的动态库中。</li>
</ul>
<p>链接的原理：<br>C++ 的编译过程通常分为⼏个步骤，其中链接是⾮常重要的⼀个环节。整个流程可以分为以下⼏个步骤：</p>
<ol>
<li>预处理（Preprocessing）：对源代码进⾏宏展开、头⽂件包含等预处理操作。</li>
<li>编译（Compilation）：将预处理后的 C++ 源代码转换为⽬标代码（机器码），⽣成.o 或.obj ⽂件（⽬标⽂件）。</li>
<li>链接（Linking）：将所有⽬标⽂件与库⽂件进⾏链接，⽣成最终的可执⾏⽂件。</li>
</ol>
<p>静态链接与动态链接的区别</p>
<h2 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型函数模板，允许不同类型的参数 T 和 U</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T a, U b)</span> -&gt; <span class="title">decltype</span><span class="params">(a + b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 使⽤模板函数处理不同类型的数据</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;整数相加: &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出 8</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;浮点数相加: &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">2.5</span>, <span class="number">4.5</span>) &lt;&lt; std::endl; <span class="comment">// 输出 7</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;字符相加: &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="string">&#x27;A&#x27;</span>, <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">// 输出 &#x27;C&#x27;(ASCII 运算)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;整数和浮点数相加: &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4.5</span>) &lt;&lt; std::endl; <span class="comment">// 输出 7.5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="前置知识-C-11-14-17-新特性-auto-lambda-shared-ptr"><a href="#前置知识-C-11-14-17-新特性-auto-lambda-shared-ptr" class="headerlink" title="前置知识-C++11&#x2F;14&#x2F;17 新特性(auto lambda shared_ptr)"></a>前置知识-C++11&#x2F;14&#x2F;17 新特性(auto lambda shared_ptr)</h1><h2 id="C-编译过程"><a href="#C-编译过程" class="headerlink" title="C++ 编译过程"></a>C++ 编译过程</h2><ol>
<li><strong>预处理</strong>（Preprocessing）<ul>
<li>宏定义展开：使⽤ #define 定义的宏会被替换为其内容。</li>
<li>处理头⽂件： #include 指令会将指定头⽂件的内容插⼊到源代码中。</li>
<li>删除注释：预处理器会移除所有注释内容，</li>
</ul>
</li>
<li><strong>词法分析</strong>（Lexical Analysis）<ul>
<li>预处理后的⽂本被编译器分解成⼀系列符号或标记（tokens）。这些tokens包括关键字、标识符、常量、运算符和分隔符等。</li>
<li>⽰例：对于语句 int a &#x3D; 5; ，会分解为以下tokens： int 、 a 、 &#x3D; 、 5 和 ; 。</li>
</ul>
</li>
<li><strong>语法分析</strong>（Syntax Analysis 或 Parsing）<ul>
<li>编译器根据C++的语法规则，将tokens组合成结构化的数据结构，即<strong>抽象语法树</strong>（AST）。</li>
</ul>
</li>
<li><strong>语义分析</strong>（Semantic Analysis）<ul>
<li>在构建AST的同时，编译器进⾏语义检查，以确保所有变量和函数的声明与使⽤符合语义规则。</li>
<li>包括类型检查、作⽤域解析和其他静态语义规则的验证。例如，如果尝试将字符串赋值给整型变量，编译器将在这⼀阶段报告错误。</li>
</ul>
</li>
<li><strong>中间代码⽣成</strong>（Intermediate Code Generation）<ul>
<li>编译器⽣成⼀种与特定机器⽆关的中间表⽰形式，如字节码或三地址码。这种形式便于后续的优化和跨平台移植。</li>
</ul>
</li>
<li><strong>优化</strong>（Optimization）<ul>
<li>编译器对中间代码进⾏各种优化，以提⾼运⾏效率和减少资源消耗。</li>
<li>优化⽰例：循环优化，死代码删除，常量传播。</li>
</ul>
</li>
<li><strong>⽬标代码⽣成</strong>（Code Generation）<ul>
<li>编译器将优化后的中间代码转换为特定计算机架构的⽬标代码（Object Code），⽬标代码通常为汇编语⾔或直接是⼆进制格式，能被CPU执⾏</li>
</ul>
</li>
<li><strong>链接</strong>（Linking）<ul>
<li>最后，链接器将多个⽬标代码⽂件及必要的库⽂件合并，形成最终的可执⾏⽂件</li>
</ul>
</li>
</ol>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><ul>
<li>shared_ptr：是⼀种共享拥有权的智能指针，多个 shared_ptr 可以指向相同的对象。它的原理包括：<ul>
<li>内部引⽤计数： shared_ptr 内部维护⼀个引⽤计数，记录有多少个 shared_ptr 共享同⼀对象。</li>
<li>拥有权：当⼀个 shared_ptr 指向⼀个对象时，引⽤计数增加。当 shared_ptr 超出作⽤域或被显式重置时，引⽤计数减少。当引⽤计数为零时，对象被⾃动释放。这种机制确保了对象的⽣命周期与 shared_ptr 的⽣命周期⼀致，避免了内存泄漏和悬挂指针的问题</li>
</ul>
</li>
<li>std::unique_ptr 是⼀种独占拥有权的智能指针，只能有⼀个 unique_ptr 指向对象。其原理包括：<ul>
<li>禁⽌复制构造和赋值： unique_ptr 不允许复制构造和赋值，因此它只能有⼀个所有权。</li>
<li>移动语义：通过移动语义， unique_ptr 可以将所有权从⼀个指针转移到另⼀个，使得资源的管理更⾼效。这种机制确保了对象的独占拥有权，避免了资源的重复释放和多个指针同时指向⼀个对象的问题。</li>
</ul>
</li>
<li>std::weak_ptr ：配合 shared_ptr 使⽤，作为观察者，不影响引⽤计数。解决了循环引⽤的问题</li>
</ul>
<h2 id="新特性："><a href="#新特性：" class="headerlink" title="新特性："></a>新特性：</h2><ul>
<li>C++11<ol>
<li>范围for循环（Range-based for loop）：允许⽅便地遍历容器。</li>
<li>右值引⽤（Rvalue References）和移动语义（Move Semantics）：允许资源的转移⽽⾮拷⻉，提⾼性能。</li>
<li>初始化列表（Initializer lists）：⽤于容器和对象的统⼀初始化⽅式。</li>
<li>线程⽀持库（Threading Library）：⽀持多线程编程。</li>
</ol>
</li>
<li>C++14<ol>
<li>返回类型推导（Return type deduction）：函数返回类型可以⽤ auto 关键字⾃动推导。</li>
<li>泛型Lambda表达式（Generic lambdas）：Lambda表达式可以使⽤ auto 在参数中实现参数类型推导。</li>
</ol>
</li>
<li>C++17<ol>
<li>并⾏算法（Parallel algorithms）：标准库算法的并⾏版本，⽤于提⾼性能。</li>
</ol>
</li>
</ul>
<h1 id="前置知识-Linux基础知识"><a href="#前置知识-Linux基础知识" class="headerlink" title="前置知识-Linux基础知识"></a>前置知识-Linux基础知识</h1><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>操作系统是⼀个控制和管理计算机硬件与软件资源的软件系统</p>
<h2 id="Linux特性"><a href="#Linux特性" class="headerlink" title="Linux特性"></a>Linux特性</h2><ol>
<li><strong>⼀切皆⽂件</strong>（Everything is a file）： 在Linux中，⽆论是硬件设备、⽬录、常规⽂件还是⽹络套接字等资源，都被抽象为“⽂件”，并可通过统⼀的系统调⽤来操作。这意味着你可以对它们进⾏读写操作，就像对待普通⽂件⼀样。例如，硬件设备可以通过特殊的设备⽂件来访问和控制。</li>
<li><strong>强⼤的命令⾏⼯具</strong>： Linux提供了丰富的命令⾏⼯具，如 bash shell 、 grep 、 sed 、awk 、 find 等，这些⼯具可以⾼效地处理⽂本、查找信息和管理系统。</li>
<li><strong>模块化设计</strong>： Linux内核采⽤模块化设计，允许动态加载和卸载驱动程序、⽂件系统以及其他内核模块，使得系统可以根据需要灵活扩展功能。</li>
<li><strong>多⽤⼾与多任务</strong>：⽀持多个⽤⼾同时操作，能够⾼效管理多个任务</li>
</ol>
<h2 id="Linux⽂件操作与管理"><a href="#Linux⽂件操作与管理" class="headerlink" title="Linux⽂件操作与管理"></a>Linux⽂件操作与管理</h2><ol>
<li><strong>⽂件描述符</strong>：⽂件描述符是⼀个抽象指标（⼀个⾮负整数），⽤于表⽰对⽂件或其他I&#x2F;O资源的访问。</li>
<li><strong>⽂件描述符表</strong>：每个进程都有⼀张独⽴的⽂件描述符表，确保每个描述符对应着⼀个独⽴的I&#x2F;O资源。<ul>
<li>包括文件描述符（fd）和文件指针</li>
</ul>
</li>
<li><strong>打开⽂件表</strong>、<strong>i-node 表</strong>。这两张表存储了每个打开⽂件的打开⽂件句柄（open file handle）。⼀个打开⽂件句柄存储了与⼀个打开⽂件相关的全部信息。</li>
<li><strong>打开⽂件表</strong>（Open File Table）：记录了进程如何使⽤特定的打开⽂件，如当前读写位置、访问模式等。这样可以快速定位到进程对⽂件的具体操作状态，提⾼系统处理I&#x2F;O请求的效率。</li>
<li><strong>i-node 表</strong>：存储的是⽂件本⾝的元数据信息，包括但不限于⼤⼩、权限、时间戳以及指向实际数据块的指针。这些信息对于管理⽂件系统中的所有⽂件是通⽤且持久的，不依赖于任何特定进程。</li>
</ol>
<h2 id="Linux⽂件操作相关函数"><a href="#Linux⽂件操作相关函数" class="headerlink" title="Linux⽂件操作相关函数"></a>Linux⽂件操作相关函数</h2><h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><ul>
<li>功能：⽤于打开⽂件或设备，返回⼀个⽂件描述符。</li>
<li>原型：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>pathname ：要打开的⽂件路径。</li>
<li>flags ：打开⽂件的模式，如只读（ O_RDONLY ）、只写（ O_WRONLY ）、读写（ O_RDWR ）等。</li>
<li>mode ：设置新⽂件的权限，仅在创建新⽂件时使⽤。</li>
</ul>
</li>
</ul>
<h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><ul>
<li>功能：从⽂件描述符指向的⽂件中读取数据。</li>
<li>原型：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>fd ：⽂件描述符。</li>
<li>buf ：数据读取后存放的缓冲区地址。</li>
<li>count ：要读取的字节数。</li>
<li>返回值：⼀个 ssize_t 类型的整数，它表⽰成功读取的字节数或者出现错误时的返回值。</li>
</ul>
</li>
<li>错误：如果读取过程中出现错误，返回-1，并设置全局变量 errno 来指⽰出现的具体错误类型。如：<ul>
<li>EINTR ：读取操作被信号中断。</li>
<li>EFAULT ： buf 指针⽆效，即指向的内存不可访问。</li>
<li>EIO ：发⽣硬件I&#x2F;O错误。</li>
<li>EISDIR ：试图从⽬录⽂件中读取数据</li>
</ul>
</li>
</ul>
<h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><ul>
<li>功能：向⽂件描述符指向的⽂件写⼊数据。</li>
<li>原型：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>fd ：⽂件描述符。</li>
<li>buf ：要写⼊⽂件的数据的缓冲区地址。</li>
<li>count ：要写⼊的字节数。</li>
</ul>
</li>
</ul>
<h3 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h3><ul>
<li>功能：重新定位⽂件描述符的⽂件偏移量。</li>
<li>原型：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">off_t</span> <span class="title">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>fd ：⽂件描述符。</li>
<li>offset ：相对偏移量。</li>
<li>whence ：偏移量的起始位置，如⽂件开头（ SEEK_SET ）、当前位置（ SEEK_CUR ）、⽂件末尾（ SEEK_END)。</li>
</ul>
</li>
</ul>
<h3 id="stat函数"><a href="#stat函数" class="headerlink" title="stat函数"></a>stat函数</h3><ul>
<li>功能：获取⽂件的状态信息。</li>
<li>原型：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>pathname ：⽂件路径。</li>
<li>statbuf ： stat 结构体，存储获取到的⽂件信息。</li>
</ul>
</li>
</ul>
<h3 id="⽬录操作函数"><a href="#⽬录操作函数" class="headerlink" title="⽬录操作函数"></a>⽬录操作函数</h3><ul>
<li>功能：提供了⼀系列操作⽬录的函数，如：<ul>
<li>opendir ：打开⼀个⽬录流。</li>
<li>readdir ：读取⽬录流中的下⼀个⽬录项。</li>
<li>closedir ：关闭⽬录流。</li>
</ul>
</li>
</ul>
<h3 id="dup函数和dup2函数"><a href="#dup函数和dup2函数" class="headerlink" title="dup函数和dup2函数"></a>dup函数和dup2函数</h3><ul>
<li>dup函数：⽤于复制⽂件描述符。</li>
<li>dup ：创建⼀个新的⽂件描述符，复制指定的⽂件描述符。</li>
<li>dup2函数：与 dup 类似，但可以指定新的⽂件描述符值。</li>
</ul>
<h3 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h3><ul>
<li>功能：改变已打开的⽂件的性质。</li>
<li>原型：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>用途：包括改变⽂件描述符的标志、对⽂件加锁等。</li>
</ul>
<h2 id="GCC编译"><a href="#GCC编译" class="headerlink" title="GCC编译"></a>GCC编译</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc program.c -o program</span><br><span class="line">g++ program.c -o program</span><br></pre></td></tr></table></figure>
<p>编译选项<br>只需记住：优化级别越⾼，编译过程越慢，编译出来的程序越快</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o my_program my_program.c -lm -L/path/to/libm</span><br></pre></td></tr></table></figure>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: program</span></span><br><span class="line"></span><br><span class="line"><span class="section">program: program.o</span></span><br><span class="line">    gcc program.o -o program</span><br><span class="line">    </span><br><span class="line"><span class="section">program.o: program.c</span></span><br><span class="line">    gcc -c program.c</span><br><span class="line">    </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f program program.o</span><br></pre></td></tr></table></figure>
<ul>
<li>伪⽬标： all 和 clean 是伪⽬标，它们不代表⽂件，⽽是规则的名字。</li>
<li>依赖关系： program 依赖于 program.o ， program.o 依赖于 program.c 。</li>
<li>规则：每个规则后的⾏定义了如何⽣成⽬标⽂件，例如⽤ gcc 来编译 .c ⽂件或链接 .o ⽂件。</li>
<li>清理： clean 规则⽤于删除编译过程中产⽣的⽂件。</li>
<li>规则：Makefile由⼀系列的规则构成。每个规则的格式通常为：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">⽬标: 依赖</span></span><br><span class="line">    命令</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb program</span><br><span class="line">(gdb) <span class="built_in">break</span> main</span><br><span class="line">(gdb) run</span><br><span class="line">(gdb) <span class="built_in">print</span> variable</span><br><span class="line">(gdb) continue</span><br></pre></td></tr></table></figure>
<p>GDB调试⼯具的基本使⽤⽅法：</p>
<ol>
<li>启动GDB：通常使⽤命令 gdb executable 来启动GDB，其中executable是你的程序⽂件。</li>
<li>设置断点：在源代码中某⼀⾏设置断点，可以使⽤命令 break filename:linenumber 或者 break function_name。<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">break</span> main.cpp:<span class="number">10</span></span><br></pre></td></tr></table></figure></li>
<li>运⾏程序：使⽤ run [args] 命令运⾏程序，可以传递命令⾏参数给程序。<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run arg1 arg2</span><br></pre></td></tr></table></figure></li>
<li>查看变量：在程序暂停时，可以通过 print variable 查看变量的当前值。<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">print</span> myVariable</span><br></pre></td></tr></table></figure></li>
<li>单步执⾏：</li>
</ol>
<ul>
<li>next （n）：执⾏下⼀⾏代码，如果下⼀⾏是函数调⽤，则整个函数体将被执⾏。</li>
<li>step （s）：单步执⾏，如果遇到函数调⽤，将进⼊该函数内部。</li>
</ul>
<ol>
<li>继续执⾏：使⽤ continue （c）命令继续执⾏程序，直到遇到下⼀个断点或者程序结束。</li>
<li>查看堆栈信息：使⽤ backtrace （bt）命令查看调⽤堆栈，了解函数调⽤层级及各层的局部变量情况。</li>
</ol>
<h2 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h2><p>每个进程在Linux中拥有独⽴的虚拟地址空间，是对物理内存的抽象。这提供了内存保护和地址隔离的功能。</p>
<h1 id="前置知识-⽹络编程基础"><a href="#前置知识-⽹络编程基础" class="headerlink" title="前置知识-⽹络编程基础"></a>前置知识-⽹络编程基础</h1><h2 id="IP-和端⼝"><a href="#IP-和端⼝" class="headerlink" title="IP 和端⼝"></a>IP 和端⼝</h2><p><strong>IP</strong> (ipv4 &amp;&amp; ipv6)</p>
<ul>
<li>定义：IP 地址（Internet Protocol Address）是指分配给⽹络设备的唯⼀地址，⽤于标识⽹络中的每⼀台计算机或设备。</li>
<li>作用：在⽹络通信中，IP 地址⽤于定位和识别设备，以确保数据能够准确地从源地址发送到⽬的地址<br><strong>端⼝号</strong></li>
<li>定义：端⼝号是⽤于标识计算机上特定进程或⽹络服务的数字，范围从 0 到 65535。</li>
<li>作⽤：通过端⼝号，操作系统能够将收到的数据包准确地交给对应的应⽤程序。</li>
</ul>
<h2 id="⽹络模型"><a href="#⽹络模型" class="headerlink" title="⽹络模型"></a>⽹络模型</h2><h3 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h3><ol>
<li>物理层（Physical Layer）</li>
</ol>
<ul>
<li>功能：传输⽐特流（0 和 1），定义物理设备标准，如电压、电缆类型、传输速率。</li>
<li>⽰例：⽹线、集线器、光纤。</li>
</ul>
<ol start="2">
<li>数据链路层（Data Link Layer）</li>
</ol>
<ul>
<li>功能：将⽐特流组织成数据帧，进⾏物理地址（MAC 地址）寻址，提供错误检测。</li>
<li>⽰例：⽹卡驱动、交换机。</li>
</ul>
<ol start="3">
<li>⽹络层（Network Layer）</li>
</ol>
<ul>
<li>功能：负责逻辑地址（IP 地址）寻址和路由选择，实现⽹络间的数据传输。</li>
<li>⽰例：IP 协议、路由器。</li>
</ul>
<ol start="4">
<li>传输层（Transport Layer）</li>
</ol>
<ul>
<li>功能：提供端到端的可靠或不可靠传输服务，数据传输的错误检测和恢复。</li>
<li>⽰例：TCP、UDP 协议。</li>
</ul>
<ol start="5">
<li>会话层（Session Layer）</li>
</ol>
<ul>
<li>功能：管理通信会话，建⽴、维护和终⽌会话。</li>
<li>⽰例：RPC、SQL 会话。</li>
</ul>
<ol start="6">
<li>表⽰层（Presentation Layer）</li>
</ol>
<ul>
<li>功能：数据的格式化、加密、解密、压缩。</li>
<li>⽰例：JPEG、MPEG、SSL&#x2F;TLS。</li>
</ul>
<ol start="7">
<li>应⽤层（Application Layer）</li>
</ol>
<ul>
<li>功能：为应⽤程序提供⽹络服务。</li>
<li>⽰例：HTTP、FTP、SMTP。</li>
</ul>
<h3 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP&#x2F;IP 四层模型"></a>TCP&#x2F;IP 四层模型</h3><p>TCP&#x2F;IP 模型是互联⽹中实际使⽤的模型，更加简化实⽤，将通信过程分为四个层次：</p>
<ol>
<li>链路层（Link Layer）</li>
</ol>
<ul>
<li>对应 OSI 的物理层和数据链路层。</li>
<li>功能：处理硬件设备和数据帧传输。</li>
<li>⽰例：以太⽹、Wi-Fi。</li>
</ul>
<ol start="2">
<li>⽹络层（Internet Layer）</li>
</ol>
<ul>
<li>对应 OSI 的⽹络层。</li>
<li>功能：处理 IP 地址寻址和路由。</li>
<li>⽰例：IP 协议、ICMP。</li>
</ul>
<ol start="3">
<li>传输层（Transport Layer）</li>
</ol>
<ul>
<li>对应 OSI 的传输层。</li>
<li>功能：提供端到端的数据传输服务。</li>
<li>⽰例：TCP、UDP 协议。</li>
</ul>
<ol start="4">
<li>应⽤层（Application Layer）</li>
</ol>
<ul>
<li>对应 OSI 的会话层、表⽰层、应⽤层。</li>
<li>功能：为应⽤程序提供⽹络服务。</li>
<li>⽰例：HTTP、FTP、DNS。</li>
</ul>
<h3 id="两种模型的⽐较"><a href="#两种模型的⽐较" class="headerlink" title="两种模型的⽐较"></a>两种模型的⽐较</h3><ul>
<li>OSI 模型更注重理论，提供了⼀个全⾯的⽹络通信框架。</li>
<li>TCP&#x2F;IP 模型更加实际，直接对应互联⽹的实际协议和应⽤。</li>
</ul>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="TCP（Transmission-Control-Protocol）"><a href="#TCP（Transmission-Control-Protocol）" class="headerlink" title="TCP（Transmission Control Protocol）"></a>TCP（Transmission Control Protocol）</h3><ul>
<li>特点：<ul>
<li>⾯向连接：通信前需要建⽴连接（三次握⼿）。</li>
<li>可靠传输：提供数据确认、重传机制，保证数据不丢失、不重复。</li>
<li>字节流传输：数据以字节流的形式传输，没有明确的消息边界。</li>
</ul>
</li>
<li>应⽤场景：⽂件传输（FTP）、邮件（SMTP）、⽹⻚浏览（HTTP&#x2F;HTTPS）。</li>
</ul>
<h3 id="UDP（User-Datagram-Protocol）"><a href="#UDP（User-Datagram-Protocol）" class="headerlink" title="UDP（User Datagram Protocol）"></a>UDP（User Datagram Protocol）</h3><ul>
<li>特点：<ul>
<li>⽆连接：不需要建⽴连接，直接发送数据。</li>
<li>不可靠传输：不保证数据到达，不提供重传机制。</li>
<li>数据报传输：以独⽴的数据报形式传输，有明确的消息边界。</li>
</ul>
</li>
<li>应⽤场景：视频直播、在线游戏、语⾳通话、DNS 查询。</li>
</ul>
<h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><h3 id="⼤端字节序（Big-Endian）"><a href="#⼤端字节序（Big-Endian）" class="headerlink" title="⼤端字节序（Big Endian）"></a>⼤端字节序（Big Endian）</h3><ul>
<li>定义：⾼位字节存储在内存的低地址处，低位字节存储在⾼地址处。</li>
<li>形象⽐喻：数据的⾼位在左边，像阅读书本⼀样从左到右。</li>
</ul>
<h3 id="⼩端字节序（Little-Endian）"><a href="#⼩端字节序（Little-Endian）" class="headerlink" title="⼩端字节序（Little Endian）"></a>⼩端字节序（Little Endian）</h3><ul>
<li>定义：低位字节存储在内存的低地址处，⾼位字节存储在⾼地址处。</li>
<li>形象⽐喻：数据的低位在左边，与⼤端相反。</li>
</ul>
<h3 id="⽹络字节序"><a href="#⽹络字节序" class="headerlink" title="⽹络字节序"></a>⽹络字节序</h3><ul>
<li>定义：为了在不同字节序的主机之间正确传输数据，⽹络通信统⼀采⽤⼤端字节序。</li>
<li>转换函数：</li>
<li>htonl ：将 32 位主机字节序转换为⽹络字节序。</li>
<li>htons ：将 16 位主机字节序转换为⽹络字节序。</li>
<li>ntohl ：将 32 位⽹络字节序转换为主机字节序。</li>
<li>ntohs ：将 16 位⽹络字节序转换为主机字节序。</li>
</ul>
<h3 id="为什么需要统⼀字节序"><a href="#为什么需要统⼀字节序" class="headerlink" title="为什么需要统⼀字节序"></a>为什么需要统⼀字节序</h3><ul>
<li>原因：不同计算机架构可能采⽤不同的字节序，如果不统⼀，会导致数据解析错误。</li>
<li>解决⽅案：在⽹络通信中，发送⽅将数据转换为⽹络字节序，接收⽅再转换回主机字节序。</li>
</ul>
<h2 id="IP-操作函数"><a href="#IP-操作函数" class="headerlink" title="IP 操作函数"></a>IP 操作函数</h2><h3 id="inet-pton-函数"><a href="#inet-pton-函数" class="headerlink" title="inet_pton 函数"></a>inet_pton 函数</h3><ul>
<li>作⽤：将点分⼗进制的 IP 地址字符串转换为⽹络字节序的数值形式。</li>
<li>原型：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>af ：地址族， AF_INET 表⽰ IPv4， AF_INET6 表⽰ IPv6。</li>
<li>src ：点分⼗进制的 IP 地址字符串。</li>
<li>dst ：指向存储结果的内存地址。</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功：返回 1。</li>
<li>失败：返回 0（⽆效地址）或 -1（系统错误）。</li>
</ul>
</li>
</ul>
<h3 id="inet-ntop-函数"><a href="#inet-ntop-函数" class="headerlink" title="inet_ntop 函数"></a>inet_ntop 函数</h3><ul>
<li>作⽤：将⽹络字节序的 IP 地址数值转换为点分⼗进制的字符串形式。</li>
<li>原型：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, socklen_tsize)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数：<ul>
<li>af ：地址族， AF_INET 或 AF_INET6 。</li>
<li>src ：指向⽹络字节序的 IP 地址数值。</li>
<li>dst ：⽤于存储结果字符串的缓冲区。</li>
<li>size ：缓冲区⼤⼩，IPv4 通常为 INET_ADDRSTRLEN （16）。</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功：返回指向结果字符串的指针。</li>
<li>失败：返回 NULL 。</li>
</ul>
</li>
</ul>
<h3 id="⽰例代码"><a href="#⽰例代码" class="headerlink" title="⽰例代码"></a>⽰例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点分⼗进制 IP 地址字符串</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip_str = <span class="string">&quot;192.168.1.1&quot;</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> addr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将字符串转换为⽹络字节序的数值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">inet_pton</span>(AF_INET, ip_str, &amp;addr) == <span class="number">1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换后的⽹络字节序数值: &quot;</span> &lt;&lt; addr.s_addr &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;⽆法将 IP 地址转换为数值形式&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// ⽤于存储转换后的字符串</span></span><br><span class="line">    <span class="type">char</span> ip_buffer[INET_ADDRSTRLEN];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将⽹络字节序的数值转换回字符串</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">inet_ntop</span>(AF_INET, &amp;addr, ip_buffer, INET_ADDRSTRLEN) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换回的点分⼗进制 IP 地址: &quot;</span> &lt;&lt; ip_buffer &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;⽆法将数值形式转换回 IP 地址字符串&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">转换后的⽹络字节序数值: <span class="number">16885952</span></span><br><span class="line">转换回的点分⼗进制 IP 地址: <span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="Socket-基础"><a href="#Socket-基础" class="headerlink" title="Socket 基础"></a>Socket 基础</h2><h3 id="什么是-Socket"><a href="#什么是-Socket" class="headerlink" title="什么是 Socket"></a>什么是 Socket</h3><ul>
<li>定义：Socket（套接字）是⽹络通信的端点，⽤于描述 IP 地址和端⼝，是应⽤程序与⽹络之间的接⼝。</li>
<li>作⽤：通过 Socket，应⽤程序可以向⽹络中发送和接收数据，实现进程间的通信。</li>
</ul>
<h3 id="Socket-的类型"><a href="#Socket-的类型" class="headerlink" title="Socket 的类型"></a>Socket 的类型</h3><ul>
<li>流式套接字（SOCK_STREAM）：⽤于⾯向连接的 TCP 通信，提供可靠的数据传输。</li>
<li>数据报套接字（SOCK_DGRAM）：⽤于⽆连接的 UDP 通信，不保证数据可靠性。</li>
</ul>
<h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ol>
<li>创建套接字：调⽤ socket() 函数，指定地址族、套接字类型和协议。</li>
<li>绑定地址（服务器端）：调⽤ bind() 函数，将套接字绑定到特定的 IP 地址和端⼝号。</li>
<li>监听连接（服务器端）：调⽤ listen() 函数，等待客⼾端的连接请求。</li>
<li>接受连接（服务器端）：调⽤ accept() 函数，建⽴与客⼾端的连接。</li>
<li>连接服务器（客⼾端）：调⽤ connect() 函数，向服务器发起连接请求。</li>
<li>数据传输：使⽤ send() 、 recv() 或 write() 、 read() 进⾏数据发送和接收。</li>
<li>关闭套接字：调⽤ close() 函数，关闭连接。</li>
</ol>
<h3 id="Sockaddr-数据结构"><a href="#Sockaddr-数据结构" class="headerlink" title="Sockaddr 数据结构"></a>Sockaddr 数据结构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family; <span class="comment">// 地址族，如 AF_INET、AF_INET6</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>]; <span class="comment">// 地址数据，具体内容与地址族相关</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>sockaddr_in</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family; <span class="comment">// 地址族，必须设置为 AF_INET</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port; <span class="comment">// 16 位端⼝号，需要使⽤ `htons()` 转换为⽹络字节序</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr; <span class="comment">// 32 位 IP 地址，使⽤ `inet_pton()` 设置</span></span><br><span class="line">    <span class="type">char</span> sin_zero[<span class="number">8</span>];<span class="comment">// 填充字段，必须设置为 0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>sin_family ：地址族，IPv4 使⽤ AF_INET 。</li>
<li>sin_port ：端⼝号，注意转换字节序。</li>
<li>sin_addr ：IP 地址，可以使⽤ INADDR_ANY 绑定所有本地地址。<br><strong>sockaddr_in6</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin6_family; <span class="comment">// 地址族，AF_INET6</span></span><br><span class="line">    <span class="type">in_port_t</span> sin6_port; <span class="comment">// 端⼝号，⽹络字节序</span></span><br><span class="line">    <span class="type">uint32_t</span> sin6_flowinfo; <span class="comment">// 流信息，通常为 0</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in6_addr</span> sin6_addr; <span class="comment">// IPv6 地址</span></span><br><span class="line">    <span class="type">uint32_t</span> sin6_scope_id; <span class="comment">// 作⽤域 ID，通常为 0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使⽤"><a href="#使⽤" class="headerlink" title="使⽤"></a>使⽤</h3><ul>
<li>在调⽤ Socket 函数时，需要将具体的地址结构转换为通⽤的 sockaddr 结构。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line"><span class="comment">// ... 初始化 addr ...</span></span><br><span class="line"><span class="built_in">bind</span>(sock_fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="TCP-通信"><a href="#TCP-通信" class="headerlink" title="TCP 通信"></a>TCP 通信</h2><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><ol>
<li>创建套接字： socket()<ul>
<li>指定地址族 AF_INET 、套接字类型 SOCK_STREAM 、协议 0 。</li>
</ul>
</li>
<li>绑定地址： bind()<ul>
<li>将套接字绑定到指定的 IP 地址和端⼝号。</li>
</ul>
</li>
<li>监听连接： listen()<ul>
<li>开始监听客⼾端的连接请求，指定最⼤连接数。</li>
</ul>
</li>
<li>接受连接： accept()<ul>
<li>阻塞等待客⼾端的连接请求，返回⼀个新的套接字⽤于通信。</li>
</ul>
</li>
</ol>
<h3 id="客⼾端"><a href="#客⼾端" class="headerlink" title="客⼾端"></a>客⼾端</h3><ol>
<li>创建套接字： socket()<ul>
<li>与服务器端相同。</li>
</ul>
</li>
<li>连接服务器： connect()<ul>
<li>指定服务器的 IP 地址和端⼝号，发起连接请求。</li>
</ul>
</li>
<li>数据传输<ul>
<li>发送数据： send() 或 write()</li>
<li>接收数据： recv() 或 read()</li>
</ul>
</li>
<li>关闭连接<ul>
<li>关闭套接字： close()</li>
</ul>
</li>
</ol>
<h2 id="TCP-三次握⼿"><a href="#TCP-三次握⼿" class="headerlink" title="TCP 三次握⼿"></a>TCP 三次握⼿</h2><p>建⽴ TCP 连接的过程，确保双⽅都准备好进⾏通信。<br>第⼀次握⼿</p>
<ul>
<li>客⼾端：发送 <strong>SYN 包</strong>（同步序列号），请求建⽴连接。</li>
<li>包含信息：客⼾端的初始序列号（ISN）。<br>第⼆次握⼿</li>
<li>服务器：收到 <strong>SYN 包</strong>，发送 <strong>SYN-ACK 包</strong>，表⽰同意连接。</li>
<li>包含信息：服务器的 ISN，确认序列号（客⼾端 ISN + 1）。<br>第三次握⼿</li>
<li>客⼾端：收到 <strong>SYN-ACK 包</strong>，发送 <strong>ACK 包</strong>，确认连接建⽴。</li>
<li>包含信息：确认序列号（服务器 ISN + 1）。<br>连接建⽴</li>
<li>状态：双⽅进⼊ ESTABLISHED 状态，开始数据传输。</li>
</ul>
<h2 id="TCP-滑动窗⼝"><a href="#TCP-滑动窗⼝" class="headerlink" title="TCP 滑动窗⼝"></a>TCP 滑动窗⼝</h2><p>流量控制机制，⽤于控制发送⽅的发送速率，确保接收⽅有⾜够的缓冲区处理数据。<br>流量控制</p>
<ul>
<li>⽬的：防⽌发送⽅发送过快，接收⽅处理不过来，导致数据丢失。<br>滑动窗⼝机制</li>
<li>发送窗⼝：发送⽅维护，表⽰允许发送但未确认的数据量。</li>
<li>接收窗⼝：接收⽅维护，表⽰可接收数据的缓冲区⼤⼩。</li>
<li>动态调整：根据⽹络状况和接收⽅反馈，调整窗⼝⼤⼩。<br>⼯作原理</li>
</ul>
<ol>
<li>发送数据：发送⽅根据窗⼝⼤⼩发送数据，不必等待每个数据的确认。</li>
<li>接收确认：接收⽅接收数据后，发送 ACK 确认，并告知可⽤窗⼝⼤⼩。</li>
<li>窗⼝滑动：收到 ACK 后，发送⽅窗⼝向前滑动，继续发送新的数据。<br>优点</li>
</ol>
<ul>
<li>提⾼⽹络吞吐量，充分利⽤带宽。</li>
<li>避免⽹络拥塞，提⾼传输效率。</li>
</ul>
<h2 id="TCP-四次挥⼿"><a href="#TCP-四次挥⼿" class="headerlink" title="TCP 四次挥⼿"></a>TCP 四次挥⼿</h2><p>终⽌ TCP 连接的过程，确保双⽅都同意关闭连接。<br>第⼀次挥⼿</p>
<ul>
<li>主动关闭⽅（通常是客⼾端）：发送 FIN 包，表⽰不再发送数据。</li>
<li>状态变为：FIN_WAIT_1。<br>第⼆次挥⼿</li>
<li>被动关闭⽅（通常是服务器）：收到 FIN 包，发送 ACK 包，<strong>确认收到</strong>关闭请求。</li>
<li>状态变为：CLOSE_WAIT。<br>第三次挥⼿</li>
<li>被动关闭⽅：<strong>处理完剩余数据</strong>后，发送 FIN 包，表⽰<strong>同意关闭</strong>连接。</li>
<li>状态变为：LAST_ACK。<br>第四次挥⼿</li>
<li>主动关闭⽅：收到 FIN 包，发送 ACK 包，确认连接关闭。</li>
<li>状态变为：TIME_WAIT，等待⼀段时间后进⼊ CLOSED。</li>
</ul>
<p>为什么需要四次挥⼿</p>
<ul>
<li>原因：TCP 是全双⼯通信，发送和接收独⽴进⾏，双⽅需要分别关闭发送和接收通道。</li>
<li>确保双⽅都已完成数据传输，避免数据丢失。</li>
</ul>
<h2 id="TCP-通信并发处理"><a href="#TCP-通信并发处理" class="headerlink" title="TCP 通信并发处理"></a>TCP 通信并发处理</h2><p>实现⾼并发的⽹络服务器，需要有效地管理多个客⼾端连接。<br>M学⻓的考研Top帮<br>多进程模型</p>
<ul>
<li>原理：为每个客⼾端连接创建⼀个新的进程。</li>
<li>优点：进程隔离性强，安全性⾼。</li>
<li>缺点：系统开销⼤，创建进程代价⾼。<br>多线程模型</li>
<li>原理：为每个客⼾端连接创建⼀个新的线程。</li>
<li>优点：⽐多进程开销⼩，共享内存空间。</li>
<li>缺点：需要注意线程同步，可能出现竞争条件。<br>I&#x2F;O 多路复⽤</li>
<li>原理：使⽤ select 、 poll 、 epoll 等系统调⽤，⼀个进程同时管理多个⽹络连接。</li>
<li>优点：⾼效处理⼤量并发连接，资源占⽤少。</li>
<li>缺点：编程复杂度较⾼，需要管理事件和状态。</li>
</ul>
<h2 id="半关闭"><a href="#半关闭" class="headerlink" title="半关闭"></a>半关闭</h2><p>半关闭：TCP 连接的⼀⽅完成数据发送后，可以关闭发送⽅向，但仍然可以接收数据。<br>函数： shutdown(socket, how)<br>• how 参数：<br>◦ SHUT_RD ：关闭接收通道。<br>◦ SHUT_WR ：关闭发送通道。<br>◦ SHUT_RDWR ：同时关闭发送和接收通道。<br>应⽤场景</p>
<ul>
<li>⻓连接中：⼀⽅发送完数据后，通知对⽅⾃⼰不再发送数据，但仍需接收对⽅的数据。</li>
<li>节省资源：及时关闭不必要的通道，减少资源占⽤。</li>
</ul>
<h2 id="端⼝复⽤"><a href="#端⼝复⽤" class="headerlink" title="端⼝复⽤"></a>端⼝复⽤</h2><p>定义：允许多个套接字绑定到同⼀ IP 地址和端⼝号的机制。<br>实现⽅式<br>SO_REUSEADDR :</p>
<ul>
<li>作⽤：允许在套接字关闭后⽴即重⽤地址。</li>
<li>使⽤场景：服务器重启时，端⼝尚未释放，设置该选项可以⽴即绑定。</li>
</ul>
<p>SO_REUSEPORT ：</p>
<ul>
<li>作⽤：允许多个进程或线程绑定到同⼀ IP 和端⼝，实现负载均衡。</li>
<li>使⽤条件：需要内核和库的⽀持（Linux 内核 3.9 及以上）。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(sock_fd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="built_in">sizeof</span>(opt));</span><br></pre></td></tr></table></figure></li>
<li>参数说明：<ul>
<li>sock_fd ：套接字描述符。</li>
<li>SOL_SOCKET ：套接字层级。</li>
<li>SO_REUSEADDR ：选项名称。</li>
<li>&amp;opt ：选项值， 1 表⽰启⽤。</li>
</ul>
</li>
</ul>
<h1 id="前置知识-DOCKER"><a href="#前置知识-DOCKER" class="headerlink" title="前置知识 - DOCKER"></a>前置知识 - DOCKER</h1><p><strong>解决问题之“在我的电脑上能运⾏”</strong></p>
<h2 id="Docker的核⼼概念和⼯作原理"><a href="#Docker的核⼼概念和⼯作原理" class="headerlink" title="Docker的核⼼概念和⼯作原理"></a>Docker的核⼼概念和⼯作原理</h2><ul>
<li>容器（Container）：轻量级、可执⾏的软件包，封装软件代码及其所有依赖，保证应⽤在任何环<br>境中都能⼀致地运⾏。</li>
<li>镜像（Image）：容器的静态模版，包含创建容器所需的⽂件系统和应⽤程序。</li>
<li>层叠的⽂件系统：镜像采⽤层叠的⽅式存储，每个层代表镜像的⼀部分。容器启动时，Docker叠加这些层并添加⼀个可写层。</li>
<li>Docker镜像不是⼀个单⼀的、巨⼤的⽂件，⽽是由⼀系列只读的层（或称为层叠的⽂件系统层）组成。每当你执⾏⼀个 RUN 命令来安装软件包、修改配置⽂件或添加⽂件时，Docker都会创建⼀个新的层，并记录下这些更改。每个新层仅包含相对于上⼀层的差异，因此形成了⼀个⾼效的增量式存储结构。</li>
<li>隔离性：容器与主机和其他容器隔离，拥有⾃⼰的⽂件系统、⽹络配置和进程空间。</li>
<li>轻量级：容器共享主机操作系统内核，运⾏在⾃⼰的隔离空间中，⽐虚拟机更轻量级。</li>
<li>可移植性：容器包含应⽤程序及其所有依赖，可以在任何⽀持Docker的主机上运⾏。</li>
</ul>
<h2 id="Dockerfile-语法"><a href="#Dockerfile-语法" class="headerlink" title="Dockerfile 语法"></a>Dockerfile 语法</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># FROM ubuntu:latest</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换为清华⼤学的 Ubuntu 镜像源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i</span></span><br><span class="line">    <span class="string">&#x27;s/http:\/\/ports.ubuntu.com/http:\/\/mirrors.tuna.tsinghua.edu.cn/g&#x27;</span></span><br><span class="line">    /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新软件包并安装所需的库</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install -y --no-install-recommends build-essential python3 python3-</span></span><br><span class="line">pip libsqlite3-dev curl &amp;&amp; \</span><br><span class="line">    rm -rf /var/lib/apt/lists/*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制代码到容器中</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /usr/src/myapp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置⼯作⽬录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /usr/src/myapp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端⼝</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span> <span class="number">8080</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>
<h2 id="Dockerfile-中的⼀些常⽤指令"><a href="#Dockerfile-中的⼀些常⽤指令" class="headerlink" title="Dockerfile 中的⼀些常⽤指令"></a>Dockerfile 中的⼀些常⽤指令</h2><p>Dockerfile 是⼀个⽂本⽂件，包含了⼀系列指令，⽤于构建 Docker 镜像。每条指令对应⼀个镜像层。</p>
<ul>
<li>FROM：指定基础镜像，是所有 Dockerfile 必须的指令。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:20.04</span><br></pre></td></tr></table></figure></li>
<li>RUN：在镜像内执⾏命令，常⽤于安装软件或依赖。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get update &amp;&amp; apt-get install -y python3</span><br></pre></td></tr></table></figure></li>
<li>COPY：将⽂件或⽬录从上下⽂⽬录复制到镜像中。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY . /app</span><br></pre></td></tr></table></figure></li>
<li>WORKDIR：设置⼯作⽬录。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /app</span><br></pre></td></tr></table></figure></li>
<li>CMD：指定容器启动时要运⾏的命令。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;python3&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure></li>
<li>EXPOSE：声明容器监听的端⼝。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 8080</span><br></pre></td></tr></table></figure></li>
<li>ENV：设置环境变量。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV DEBUG=true</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Docker-常⻅命令"><a href="#Docker-常⻅命令" class="headerlink" title="Docker 常⻅命令"></a>Docker 常⻅命令</h2><ul>
<li>docker build: 使⽤Dockerfile构建镜像。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my-image-name .</span><br></pre></td></tr></table></figure>
其中 . 表⽰当前⽬录作为构建上下⽂， -t ⽤来指定标签名。</li>
<li>docker run: 创建并启动⼀个新的容器。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name container-name -p host-port:container-port my-image￾name</span><br></pre></td></tr></table></figure>
-d 表⽰后台运⾏， –name 为容器命名， -p 进⾏端⼝映射。</li>
<li>docker start&#x2F;stop&#x2F;restart: 控制容器的⽣命周期。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker start container-name</span><br><span class="line">docker stop container-name</span><br><span class="line">docker restart container-name</span><br></pre></td></tr></table></figure></li>
<li>docker ps: 列出正在运⾏的容器。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
若要查看所有容器（包括未运⾏的），可使⽤ docker ps -a 。</li>
<li>docker exec: 在运⾏中的容器内执⾏命令。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it container-name bash</span><br></pre></td></tr></table></figure></li>
<li>docker logs: 查看容器的⽇志输出。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs container-name</span><br></pre></td></tr></table></figure></li>
<li>docker rm: 删除容器。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm container-name</span><br></pre></td></tr></table></figure></li>
<li>docker rmi: 删除镜像。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi my-image-name</span><br></pre></td></tr></table></figure></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://yansmaoa.github.io">Ysmmm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://yansmaoa.github.io/2025/03/20/myserver-helloword/">https://yansmaoa.github.io/2025/03/20/myserver-helloword/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yansmaoa.github.io" target="_blank">Ysmmm的快乐小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/server/">server</a></div><div class="post_share"><div class="social-share" data-image="/img/v2-1cb481e27656b14e14b2878d6c47e544_r.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/03/23/myserver-helloworld-helloword/" title="myserver-helloword-helloword"><img class="cover" src="/img/v2-1cb481e27656b14e14b2878d6c47e544_r.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">myserver-helloword-helloword</div></div></a></div><div class="next-post pull-right"><a href="/2025/01/02/Linux-%E5%A4%8D%E4%B9%A02/" title="Linux 复习2"><img class="cover" src="/img/v2-1cb481e27656b14e14b2878d6c47e544_r.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux 复习2</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/03/24/myserver-helloword-database/" title="myserver-helloword-database"><img class="cover" src="/img/v2-1cb481e27656b14e14b2878d6c47e544_r.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-24</div><div class="title">myserver-helloword-database</div></div></a></div><div><a href="/2025/03/25/myserver-helloword-epoll/" title="myserver-helloword-epoll"><img class="cover" src="/img/v2-1cb481e27656b14e14b2878d6c47e544_r.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-25</div><div class="title">myserver-helloword-epoll</div></div></a></div><div><a href="/2025/03/24/myserver-helloword-http/" title="myserver-helloword-http"><img class="cover" src="/img/v2-1cb481e27656b14e14b2878d6c47e544_r.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-24</div><div class="title">myserver-helloword-http</div></div></a></div><div><a href="/2025/03/24/myserver-helloword-logger/" title="myserver-helloword-logger"><img class="cover" src="/img/v2-1cb481e27656b14e14b2878d6c47e544_r.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-24</div><div class="title">myserver-helloword-logger</div></div></a></div><div><a href="/2025/03/23/myserver-helloworld-helloword/" title="myserver-helloword-helloword"><img class="cover" src="/img/v2-1cb481e27656b14e14b2878d6c47e544_r.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-23</div><div class="title">myserver-helloword-helloword</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/saierda.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Ysmmm</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">57</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/YANSMAoA"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=1850955441&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="https://github.com/YANSMAoA" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1850955441@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-C"><span class="toc-number">1.</span> <span class="toc-text">前置知识 - C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%BE%AF%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88OOP%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">⾯向对象编程（OOP）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%EF%BC%88static%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">静态全局变量（static）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">1.4.</span> <span class="toc-text">抛出异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.</span> <span class="toc-text">堆和栈的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-STL"><span class="toc-number">2.</span> <span class="toc-text">前置知识-STL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E8%BF%9E%E6%8E%A5%E5%BA%93"><span class="toc-number">2.1.</span> <span class="toc-text">编译时连接库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5"><span class="toc-number">2.2.</span> <span class="toc-text">链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">泛型编程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-C-11-14-17-%E6%96%B0%E7%89%B9%E6%80%A7-auto-lambda-shared-ptr"><span class="toc-number">3.</span> <span class="toc-text">前置知识-C++11&#x2F;14&#x2F;17 新特性(auto lambda shared_ptr)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">C++ 编译过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">3.2.</span> <span class="toc-text">智能指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">3.3.</span> <span class="toc-text">新特性：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">4.</span> <span class="toc-text">前置知识-Linux基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.1.</span> <span class="toc-text">操作系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E7%89%B9%E6%80%A7"><span class="toc-number">4.2.</span> <span class="toc-text">Linux特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E2%BD%82%E4%BB%B6%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%AE%A1%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">Linux⽂件操作与管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E2%BD%82%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.</span> <span class="toc-text">Linux⽂件操作相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#open"><span class="toc-number">4.4.1.</span> <span class="toc-text">open</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#read"><span class="toc-number">4.4.2.</span> <span class="toc-text">read</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#write"><span class="toc-number">4.4.3.</span> <span class="toc-text">write</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lseek"><span class="toc-number">4.4.4.</span> <span class="toc-text">lseek</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stat%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.5.</span> <span class="toc-text">stat函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%BD%AC%E5%BD%95%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.6.</span> <span class="toc-text">⽬录操作函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dup%E5%87%BD%E6%95%B0%E5%92%8Cdup2%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.7.</span> <span class="toc-text">dup函数和dup2函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fcntl%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.8.</span> <span class="toc-text">fcntl函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GCC%E7%BC%96%E8%AF%91"><span class="toc-number">4.5.</span> <span class="toc-text">GCC编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Makefile"><span class="toc-number">4.6.</span> <span class="toc-text">Makefile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GDB%E8%B0%83%E8%AF%95"><span class="toc-number">4.7.</span> <span class="toc-text">GDB调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">4.8.</span> <span class="toc-text">虚拟地址空间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-%E2%BD%B9%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">5.</span> <span class="toc-text">前置知识-⽹络编程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IP-%E5%92%8C%E7%AB%AF%E2%BC%9D"><span class="toc-number">5.1.</span> <span class="toc-text">IP 和端⼝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%BD%B9%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">⽹络模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OSI-%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.2.1.</span> <span class="toc-text">OSI 七层模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP-%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.2.2.</span> <span class="toc-text">TCP&#x2F;IP 四层模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%9E%8B%E7%9A%84%E2%BD%90%E8%BE%83"><span class="toc-number">5.2.3.</span> <span class="toc-text">两种模型的⽐较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.3.</span> <span class="toc-text">协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%EF%BC%88Transmission-Control-Protocol%EF%BC%89"><span class="toc-number">5.3.1.</span> <span class="toc-text">TCP（Transmission Control Protocol）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%EF%BC%88User-Datagram-Protocol%EF%BC%89"><span class="toc-number">5.3.2.</span> <span class="toc-text">UDP（User Datagram Protocol）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">5.4.</span> <span class="toc-text">字节序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%BC%A4%E7%AB%AF%E5%AD%97%E8%8A%82%E5%BA%8F%EF%BC%88Big-Endian%EF%BC%89"><span class="toc-number">5.4.1.</span> <span class="toc-text">⼤端字节序（Big Endian）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%BC%A9%E7%AB%AF%E5%AD%97%E8%8A%82%E5%BA%8F%EF%BC%88Little-Endian%EF%BC%89"><span class="toc-number">5.4.2.</span> <span class="toc-text">⼩端字节序（Little Endian）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%BD%B9%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">5.4.3.</span> <span class="toc-text">⽹络字节序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BB%9F%E2%BC%80%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">5.4.4.</span> <span class="toc-text">为什么需要统⼀字节序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP-%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number">5.5.</span> <span class="toc-text">IP 操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#inet-pton-%E5%87%BD%E6%95%B0"><span class="toc-number">5.5.1.</span> <span class="toc-text">inet_pton 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inet-ntop-%E5%87%BD%E6%95%B0"><span class="toc-number">5.5.2.</span> <span class="toc-text">inet_ntop 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%BD%B0%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">5.5.3.</span> <span class="toc-text">⽰例代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket-%E5%9F%BA%E7%A1%80"><span class="toc-number">5.6.</span> <span class="toc-text">Socket 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Socket"><span class="toc-number">5.6.1.</span> <span class="toc-text">什么是 Socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket-%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.6.2.</span> <span class="toc-text">Socket 的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="toc-number">5.6.3.</span> <span class="toc-text">基本流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sockaddr-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.6.4.</span> <span class="toc-text">Sockaddr 数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E2%BD%A4"><span class="toc-number">5.6.5.</span> <span class="toc-text">使⽤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E9%80%9A%E4%BF%A1"><span class="toc-number">5.7.</span> <span class="toc-text">TCP 通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF"><span class="toc-number">5.7.1.</span> <span class="toc-text">服务器端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E2%BC%BE%E7%AB%AF"><span class="toc-number">5.7.2.</span> <span class="toc-text">客⼾端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E2%BC%BF"><span class="toc-number">5.8.</span> <span class="toc-text">TCP 三次握⼿</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E6%BB%91%E5%8A%A8%E7%AA%97%E2%BC%9D"><span class="toc-number">5.9.</span> <span class="toc-text">TCP 滑动窗⼝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E2%BC%BF"><span class="toc-number">5.10.</span> <span class="toc-text">TCP 四次挥⼿</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E9%80%9A%E4%BF%A1%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86"><span class="toc-number">5.11.</span> <span class="toc-text">TCP 通信并发处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8A%E5%85%B3%E9%97%AD"><span class="toc-number">5.12.</span> <span class="toc-text">半关闭</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%AF%E2%BC%9D%E5%A4%8D%E2%BD%A4"><span class="toc-number">5.13.</span> <span class="toc-text">端⼝复⽤</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-DOCKER"><span class="toc-number">6.</span> <span class="toc-text">前置知识 - DOCKER</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E7%9A%84%E6%A0%B8%E2%BC%BC%E6%A6%82%E5%BF%B5%E5%92%8C%E2%BC%AF%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">6.1.</span> <span class="toc-text">Docker的核⼼概念和⼯作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dockerfile-%E8%AF%AD%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">Dockerfile 语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dockerfile-%E4%B8%AD%E7%9A%84%E2%BC%80%E4%BA%9B%E5%B8%B8%E2%BD%A4%E6%8C%87%E4%BB%A4"><span class="toc-number">6.3.</span> <span class="toc-text">Dockerfile 中的⼀些常⽤指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E5%B8%B8%E2%BB%85%E5%91%BD%E4%BB%A4"><span class="toc-number">6.4.</span> <span class="toc-text">Docker 常⻅命令</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/25/myserver-helloword-epoll/" title="myserver-helloword-epoll">myserver-helloword-epoll</a><time datetime="2025-03-25T06:21:27.000Z" title="发表于 2025-03-25 14:21:27">2025-03-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/24/myserver-helloword-database/" title="myserver-helloword-database">myserver-helloword-database</a><time datetime="2025-03-24T13:37:00.000Z" title="发表于 2025-03-24 21:37:00">2025-03-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/24/myserver-helloword-logger/" title="myserver-helloword-logger">myserver-helloword-logger</a><time datetime="2025-03-24T03:21:34.000Z" title="发表于 2025-03-24 11:21:34">2025-03-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/24/myserver-helloword-http/" title="myserver-helloword-http">myserver-helloword-http</a><time datetime="2025-03-24T02:34:22.000Z" title="发表于 2025-03-24 10:34:22">2025-03-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/23/myserver-helloworld-helloword/" title="myserver-helloword-helloword">myserver-helloword-helloword</a><time datetime="2025-03-23T09:09:42.000Z" title="发表于 2025-03-23 17:09:42">2025-03-23</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/v2-1cb481e27656b14e14b2878d6c47e544_r.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Ysmmm</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>